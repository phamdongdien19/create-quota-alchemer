<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alchemer Bulk Quota Manager</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #8892b0;
            font-size: 1.1rem;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #8892b0;
            font-weight: 500;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab.active {
            background: rgba(0, 217, 255, 0.1);
            border-color: #00d9ff;
            color: #00d9ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-title {
            font-size: 1.2rem;
            margin-bottom: 16px;
            color: #00d9ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(180deg, #00d9ff, #00ff88);
            border-radius: 2px;
        }

        .card-title.danger::before {
            background: linear-gradient(180deg, #ff5252, #ff8a80);
        }

        .card-title.danger {
            color: #ff5252;
        }

        .card-title.warning::before {
            background: linear-gradient(180deg, #ffc107, #ffeb3b);
        }

        .card-title.warning {
            color: #ffc107;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #ccd6f6;
            font-weight: 500;
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #00d9ff;
            box-shadow: 0 0 0 3px rgba(0, 217, 255, 0.2);
        }

        textarea {
            min-height: 150px;
            font-family: 'Consolas', 'Monaco', monospace;
            resize: vertical;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 16px;
        }

        @media (max-width: 600px) {

            .grid-2,
            .grid-3 {
                grid-template-columns: 1fr;
            }
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 217, 255, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #ffeb3b);
            color: #1a1a2e;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 193, 7, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff5252, #ff8a80);
            color: #fff;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 82, 82, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-sm {
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }

        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .data-table th {
            background: rgba(0, 217, 255, 0.1);
            color: #00d9ff;
            font-weight: 600;
        }

        .col-logic {
            max-width: 300px;
            min-width: 150px;
        }

        .logic-tag {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            border-radius: 6px;
            font-size: 0.8rem;
            line-height: 1.4;
            word-break: break-word;
            border: 1px solid rgba(0, 255, 136, 0.1);
            font-family: 'Consolas', monospace;
            transition: all 0.2s;
        }

        .logic-tag:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }

        /* Improved Group UI Styles */
        .group-header {
            background: rgba(255, 255, 255, 0.02) !important;
            transition: all 0.3s;
            position: relative;
        }

        .group-header td {
            padding: 12px 16px !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05) !important;
        }

        /* Dynamic Group Colors & Neon Glow */
        .group-color-0 {
            --g-color: #00d9ff;
        }

        .group-color-1 {
            --g-color: #ff5252;
        }

        .group-color-2 {
            --g-color: #ffeb3b;
        }

        .group-color-3 {
            --g-color: #da70d6;
        }

        .group-color-4 {
            --g-color: #00ff88;
        }

        .group-color-5 {
            --g-color: #ff9800;
        }

        .group-header,
        .child-row {
            border-left: 5px solid var(--g-color) !important;
            transition: all 0.3s;
        }

        .group-header:hover,
        .child-row:hover {
            background: rgba(255, 255, 255, 0.05) !important;
            box-shadow: inset 15px 0 25px -15px var(--g-color);
        }

        .group-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
            font-size: 1.05rem;
            color: var(--g-color);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .group-toggle {
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            color: var(--g-color);
            filter: drop-shadow(0 0 5px var(--g-color));
        }

        .group-toggle.collapsed {
            transform: rotate(-90deg);
        }

        /* Tree structure visualization */
        .child-row {
            background: transparent;
        }

        .child-row.is-hidden {
            display: none !important;
        }

        .tree-cell {
            position: relative;
            padding-left: 60px !important;
            /* Increased for deeper alignment */
        }

        /* Vertical line that connects all children */
        .tree-line-v {
            position: absolute;
            left: -5px;
            top: -1px;
            bottom: 0;
            width: 5px;
            /* Matches border-left thickness */
            background: var(--g-color);
            opacity: 1;
            /* Solid color */
            transition: all 0.2s;
        }

        /* Horizontal branch line */
        .tree-line-h {
            position: absolute;
            left: -5px;
            top: 50%;
            width: 25px;
            height: 2px;
            background: var(--g-color);
            opacity: 1;
            transition: all 0.2s;
        }

        /* Connection logic */
        .group-connector-cell {
            position: relative;
        }

        .group-connector-line {
            position: absolute;
            left: -5px;
            /* Offset to match parent border */
            top: 50%;
            bottom: 0;
            width: 3px;
            background: var(--g-color);
            opacity: 0.3;
        }

        .last-child .tree-line-v {
            bottom: 50%;
            border-bottom-left-radius: 4px;
        }

        .child-row:hover .tree-line-v,
        .child-row:hover .tree-line-h {
            opacity: 0.8 !important;
            box-shadow: 0 0 8px var(--g-color);
        }

        .child-row:hover input[type="text"] {
            text-decoration: underline;
            color: #00d9ff;
        }

        .drag-handle {
            font-size: 1.2rem;
            opacity: 0.3;
            transition: opacity 0.2s;
        }

        .child-row:hover .drag-handle {
            opacity: 1;
            color: #00d9ff;
        }

        .data-table tr:hover td {
            background: rgba(255, 255, 255, 0.05);
        }

        .data-table input {
            width: 80px;
            padding: 6px 10px;
            text-align: right;
        }

        .status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-pending {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .status-success {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .status-error {
            background: rgba(255, 82, 82, 0.2);
            color: #ff5252;
        }

        .status-modified {
            background: rgba(138, 43, 226, 0.2);
            color: #da70d6;
        }

        .result-summary {
            display: flex;
            gap: 20px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .result-stat {
            text-align: center;
        }

        .result-stat-value {
            font-size: 2rem;
            font-weight: 700;
        }

        .result-stat-label {
            color: #8892b0;
            font-size: 0.9rem;
        }

        .success-value {
            color: #00ff88;
        }

        .error-value {
            color: #ff5252;
        }

        .total-value {
            color: #00d9ff;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .help-text {
            color: #8892b0;
            font-size: 0.9rem;
            margin-top: 8px;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border-left: 3px solid #00d9ff;
            padding: 16px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 16px;
        }

        .warning-box {
            background: rgba(255, 193, 7, 0.1);
            border-left: 3px solid #ffc107;
            padding: 16px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 16px;
        }

        .danger-box {
            background: rgba(255, 82, 82, 0.1);
            border-left: 3px solid #ff5252;
            padding: 16px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 16px;
        }

        .info-box p,
        .warning-box p,
        .danger-box p {
            color: #ccd6f6;
            line-height: 1.6;
        }

        .adjust-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .adjust-controls input {
            width: 80px;
        }

        .adjust-controls select {
            width: 120px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        .checkbox-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }

        .change-indicator {
            font-size: 0.8rem;
            margin-left: 8px;
        }

        .change-up {
            color: #00ff88;
        }

        .change-down {
            color: #ff5252;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üöÄ Bulk Quota Manager</h1>
            <p class="subtitle">T·∫°o, ch·ªânh s·ª≠a v√† xo√° quota Alchemer h√†ng lo·∫°t</p>
        </header>

        <!-- API CONFIG -->
        <div class="card">
            <div class="card-title">C·∫•u h√¨nh API (Server-Side)</div>
            <div class="grid-3">
                <div>
                    <label>Survey ID</label>
                    <input type="text" id="surveyId" placeholder="VD: 8154556">
                </div>
            </div>
        </div>

        <!-- TABS -->
        <div class="tabs">
            <div class="tab active" onclick="switchTab('create')">‚ú® T·∫°o m·ªõi</div>
            <div class="tab" onclick="switchTab('manage')">üìù Qu·∫£n l√Ω Quota</div>
        </div>

        <!-- CREATE TAB -->
        <div id="createTab" class="tab-content active">
            <div class="card">
                <div class="card-title">C·∫•u h√¨nh Logic (M·∫∑c ƒë·ªãnh cho m·ªói Quota)</div>

                <!-- Template Selector -->
                <div style="margin-bottom: 16px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <label style="margin: 0;">üìÅ Template:</label>
                    <select id="logicTemplate" onchange="loadTemplate()" style="flex: 1; min-width: 200px;">
                        <option value="">-- Ch·ªçn template --</option>
                        <option value="link_panel">link = panel (Hidden Value)</option>
                    </select>
                    <button class="btn btn-sm btn-secondary" onclick="saveCurrentAsTemplate()">üíæ L∆∞u</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteTemplate()">üóëÔ∏è</button>
                </div>

                <div class="grid-2">
                    <div>
                        <label>Lo·∫°i Logic</label>
                        <select id="logicAnswerType" onchange="updateLogicTypeUI()">
                            <option value="2" selected>Hidden Value (Text)</option>
                            <option value="17">Question Option (Single/Multiple Answer)</option>
                        </select>
                    </div>
                    <div>
                        <label>To√°n t·ª≠ (Operator)</label>
                        <select id="logicOperator" onchange="updateLogicPreview()">
                            <option value="4" selected>is exactly equal to (b·∫±ng)</option>
                            <option value="5">is not exactly equal to (kh√¥ng b·∫±ng)</option>
                            <option value="12">is one of the following answers</option>
                            <option value="13">is not one of the following answers</option>
                            <option value="20">is answered (ƒë√£ tr·∫£ l·ªùi)</option>
                            <option value="21">is not answered (ch∆∞a tr·∫£ l·ªùi)</option>
                            <option value="14">contains (ch·ª©a)</option>
                        </select>
                    </div>
                </div>
                <div class="grid-2" style="margin-top: 16px;">
                    <div>
                        <label id="logicKeyLabel">Hidden Value ID</label>
                        <input type="text" id="logicKey" value="15" placeholder="VD: 15" oninput="updateLogicPreview()">
                        <p class="help-text" id="logicKeyHelp">üí° ID c·ªßa Hidden Value (VD: 15 cho "link")</p>
                    </div>
                    <div>
                        <label id="logicValueLabel">Gi√° tr·ªã (Value)</label>
                        <input type="text" id="logicValue" value="panel" placeholder="VD: panel"
                            oninput="updateLogicPreview()">
                        <p class="help-text" id="logicValueHelp">üí° Gi√° tr·ªã text ƒë·ªÉ so s√°nh</p>
                    </div>
                </div>
                <div style="margin-top: 15px; display: flex; align-items: center; gap: 20px; flex-wrap: wrap;">
                    <label class="checkbox-item">
                        <input type="checkbox" id="enableLogic" checked>
                        <span>S·ª≠ d·ª•ng Logic n√†y khi t·∫°o</span>
                    </label>
                    <span class="status status-success" style="font-size: 0.9rem;" id="logicPreview">Logic: HV[15] is
                        exactly equal to "panel"</span>
                </div>
            </div>

            <!-- Question Picker Tool -->
            <div class="card" id="questionPickerCard">
                <div class="card-title">üìã Ch·ªçn Questions ƒë·ªÉ t·∫°o Quota</div>

                <!-- Quick Add - Common Groups -->
                <div class="info-box" style="margin-bottom: 16px; background: rgba(0,255,136,0.1);">
                    <p style="margin-bottom: 10px;"><strong>‚ö° Th√™m nhanh nh√≥m ph·ªï bi·∫øn:</strong></p>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn btn-sm btn-primary" onclick="quickAddQuestion(87, 'province')">ÔøΩ Province
                            (87)</button>
                        <button class="btn btn-sm btn-primary" onclick="quickAddQuestion(93, 'age_group')">ÔøΩ Age Group
                            (93)</button>
                        <button class="btn btn-sm btn-primary" onclick="quickAddQuestion(75, 'family_income')">ÔøΩ Family
                            Income (75)</button>
                        <button class="btn btn-sm btn-primary" onclick="quickAddQuestion(150, 'gender')">‚öß Gender
                            (150)</button>
                        <button class="btn btn-sm btn-warning" onclick="quickAddMultipleQuestions([87, 93, 75, 150])">üî•
                            Th√™m t·∫•t c·∫£ 4 nh√≥m</button>
                    </div>
                </div>

                <div class="info-box" style="margin-bottom: 16px;">
                    <p>üí° Ho·∫∑c ch·ªçn th·ªß c√¥ng t·ª´ danh s√°ch Questions c√≥ options (Radio/Checkbox)</p>
                </div>

                <div style="display: flex; gap: 10px; margin-bottom: 16px; flex-wrap: wrap;">
                    <button class="btn btn-secondary" onclick="loadQuestionList(false)">üìã T·∫£i danh s√°ch
                        Questions</button>
                    <button class="btn btn-secondary" onclick="loadQuestionList(true)">üîÑ Refresh t·ª´ API</button>
                    <span id="questionCacheStatus" style="align-self: center; font-size: 0.85rem; opacity: 0.7;"></span>
                </div>

                <div id="questionListResult" class="hidden" style="margin-bottom: 16px;">
                    <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; align-items: center;">
                        <button class="btn btn-sm btn-primary" onclick="addSelectedQuestionsToPreview()">‚úÖ Th√™m
                            Questions ƒë√£ ch·ªçn v√†o Xem tr∆∞·ªõc</button>
                        <span id="selectedQuestionsCount" style="font-size: 0.9rem;">0 ƒë√£ ch·ªçn</span>
                    </div>
                    <div
                        style="max-height: 300px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                        <table class="data-table" style="margin: 0;">
                            <thead style="position: sticky; top: 0; background: #1a1a2e;">
                                <tr>
                                    <th><input type="checkbox" id="selectAllQuestions"
                                            onchange="toggleSelectAllQuestions(this)"></th>
                                    <th>ID</th>
                                    <th>T√™n Question</th>
                                    <th>Lo·∫°i</th>
                                    <th>Options</th>
                                </tr>
                            </thead>
                            <tbody id="questionListBody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Manual lookup for single question -->
                <details style="margin-top: 16px;">
                    <summary
                        style="cursor: pointer; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                        üîç Tra c·ª©u th·ªß c√¥ng theo Question ID
                    </summary>
                    <div style="padding: 16px 0;">
                        <div class="grid-3">
                            <div>
                                <label>Question ID</label>
                                <input type="text" id="lookupQuestionId" placeholder="VD: 93">
                            </div>
                            <div style="display: flex; align-items: flex-end;">
                                <button class="btn btn-secondary" onclick="lookupQuestionOptions()">ÔøΩ Tra c·ª©u</button>
                            </div>
                        </div>
                        <div id="optionLookupResult" class="hidden" style="margin-top: 16px;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Option</th>
                                        <th>Value</th>
                                        <th>Option ID (d√πng cho Logic)</th>
                                        <th>H√†nh ƒë·ªông</th>
                                    </tr>
                                </thead>
                                <tbody id="optionLookupBody"></tbody>
                            </table>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Cross-tab Generator -->
            <div class="card" id="crosstabCard">
                <div class="card-title" style="color: #ffc107;">üîÄ Cross-tab Generator (Quota l·ªìng nhi·ªÅu Questions)
                </div>

                <div class="warning-box" style="margin-bottom: 16px;">
                    <p>‚ö° <strong>T·∫°o quota k·∫øt h·ª£p nhi·ªÅu ƒëi·ªÅu ki·ªán:</strong> VD: "Nam + H√† N·ªôi + 18-29" = ng∆∞·ªùi nam, ·ªü
                        H√† N·ªôi, ƒë·ªô tu·ªïi 18-29</p>
                    <p style="font-size: 0.85rem; opacity: 0.8; margin-top: 8px;">üí° Ch·ªçn c√°c Questions, ch·ªçn Options t·ª´
                        m·ªói Question, r·ªìi nh·∫•n "T·∫°o Cross-tab Quotas"</p>
                </div>

                <!-- Mode Selection -->
                <div style="margin-bottom: 16px; background: rgba(0,217,255,0.1); padding: 12px; border-radius: 8px;">
                    <label style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <strong>Ch·∫ø ƒë·ªô t·∫°o quota:</strong>
                    </label>
                    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="radio" name="crosstabMode" value="cartesian" checked
                                onchange="updateCrosstabMode()">
                            <span>üî¢ <strong>Cartesian (T·ªï h·ª£p t·∫•t c·∫£)</strong> - T·∫°o t·∫•t c·∫£ t·ªï h·ª£p t·ª´ c√°c
                                dimensions</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="radio" name="crosstabMode" value="custom" onchange="updateCrosstabMode()">
                            <span>‚öôÔ∏è <strong>Custom Logic</strong> - T·ª± thi·∫øt l·∫≠p ƒëi·ªÅu ki·ªán AND/OR v√† Groups</span>
                        </label>
                    </div>
                </div>

                <!-- Cartesian Mode (Default) -->
                <div id="cartesianModeSection">
                    <div class="info-box" style="margin-bottom: 12px;">
                        <p>üìä <strong>Cartesian Mode:</strong> M·ªói dimension b·∫°n th√™m s·∫Ω ƒë∆∞·ª£c k·∫øt h·ª£p v·ªõi t·∫•t c·∫£
                            dimensions kh√°c.</p>
                        <p style="font-size: 0.85rem; margin-top: 4px;">VD: Gender (2) √ó Province (3) √ó Age (2) = 12
                            quota</p>
                    </div>

                    <!-- Operator between dimensions in Cartesian mode -->
                    <div style="margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                        <span>ƒêi·ªÅu ki·ªán gi·ªØa c√°c dimensions:</span>
                        <select id="cartesianDimOperator" style="width: 100px;">
                            <option value="and" selected>AND</option>
                            <option value="or">OR</option>
                        </select>
                        <span style="color: #8892b0; font-size: 0.85rem;">üí° AND = t·∫•t c·∫£ ƒëi·ªÅu ki·ªán ph·∫£i ƒë√∫ng, OR = √≠t
                            nh·∫•t 1 ƒëi·ªÅu ki·ªán ƒë√∫ng</span>
                    </div>

                    <!-- Selected dimensions for cross-tab -->
                    <div id="crosstabDimensions"
                        style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px;">
                        <!-- Dimension slots will be added here -->
                    </div>

                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 16px;">
                        <button class="btn btn-secondary" onclick="addCrosstabDimension()">‚ûï Th√™m Dimension
                            (Question)</button>
                        <button class="btn btn-danger btn-sm" onclick="clearCrosstabDimensions()">üóëÔ∏è X√≥a t·∫•t
                            c·∫£</button>
                    </div>
                </div>

                <!-- Custom Logic Mode -->
                <div id="customModeSection" class="hidden">
                    <div class="info-box" style="margin-bottom: 12px; background: rgba(255,193,7,0.1);">
                        <p>‚öôÔ∏è <strong>Custom Logic Mode:</strong> T·∫°o quota v·ªõi logic ph·ª©c t·∫°p, nhi·ªÅu groups.</p>
                        <p style="font-size: 0.85rem; margin-top: 4px;">M·ªói Group ch·ª©a nhi·ªÅu ƒëi·ªÅu ki·ªán. Groups k·∫øt n·ªëi
                            v·ªõi nhau b·∫±ng AND/OR.</p>
                    </div>

                    <!-- Load Questions for Dropdowns -->
                    <div
                        style="margin-bottom: 16px; padding: 12px; background: rgba(0,217,255,0.1); border-radius: 8px;">
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <span>üìã Danh s√°ch Questions:</span>
                            <button class="btn btn-sm btn-secondary" onclick="loadQuestionsForCustomLogic()">üîÑ T·∫£i
                                Questions t·ª´ API</button>
                            <span id="customQuestionsStatus" style="font-size: 0.85rem; color: #8892b0;"></span>
                        </div>
                    </div>

                    <!-- Copy/Paste Groups Template -->
                    <div
                        style="margin-bottom: 16px; padding: 12px; background: rgba(0,255,136,0.1); border-radius: 8px;">
                        <div
                            style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px;">
                            <span>üìã <strong>Copy/Paste c·∫•u tr√∫c:</strong></span>
                            <button class="btn btn-sm btn-secondary" onclick="copyGroupsStructure()">üìã Copy
                                Groups</button>
                            <button class="btn btn-sm btn-secondary" onclick="pasteGroupsStructure()">üì• Paste
                                Groups</button>
                            <button class="btn btn-sm btn-warning" onclick="cloneCurrentQuota()">‚ôªÔ∏è Clone Quota (gi·ªØ
                                nguy√™n c·∫•u tr√∫c)</button>
                        </div>
                        <p style="font-size: 0.8rem; color: #8892b0;">üí° Clone ƒë·ªÉ t·∫°o nhi·ªÅu quota c√πng c·∫•u tr√∫c, ch·ªâ
                            thay ƒë·ªïi t√™n v√† options</p>
                    </div>

                    <!-- Logic Groups Container -->
                    <div id="customLogicGroups"
                        style="display: flex; flex-direction: column; gap: 16px; margin-bottom: 16px;">
                        <!-- Groups will be added here -->
                    </div>

                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 16px;">
                        <button class="btn btn-secondary" onclick="addCustomLogicGroup()">‚ûï Th√™m Group</button>
                        <button class="btn btn-danger btn-sm" onclick="clearCustomLogicGroups()">üóëÔ∏è X√≥a t·∫•t c·∫£</button>
                    </div>

                    <!-- Custom quota name and limit -->
                    <div class="grid-2" style="margin-bottom: 12px;">
                        <div>
                            <label>T√™n Quota</label>
                            <input type="text" id="customQuotaName" placeholder="VD: 20-29 + Nam + Panel">
                        </div>
                        <div>
                            <label>Limit</label>
                            <input type="number" id="customQuotaLimit" value="50" min="1">
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-warning" onclick="addCustomQuotaToPreview()">‚úÖ Th√™m quota n√†y v√†o Xem
                            tr∆∞·ªõc</button>
                        <button class="btn btn-primary" onclick="addMultipleCustomQuotas()">‚ûï Th√™m nhi·ªÅu quota (nh·∫≠p
                            danh s√°ch t√™n)</button>
                    </div>
                </div>

                <!-- Cross-tab Preview -->
                <div id="crosstabPreview" class="hidden" style="margin-bottom: 16px; margin-top: 16px;">
                    <div style="background: rgba(0,0,0,0.2); padding: 16px; border-radius: 8px;">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <strong style="color: #00ff88;">üìä Xem tr∆∞·ªõc Cross-tab:</strong>
                            <span id="crosstabCount" style="color: #ffc107;">0 quota s·∫Ω ƒë∆∞·ª£c t·∫°o</span>
                        </div>
                        <div id="crosstabPreviewList" style="max-height: 200px; overflow-y: auto;">
                            <!-- Preview items will be here -->
                        </div>
                    </div>
                </div>

                <div class="grid-2" style="margin-bottom: 16px;" id="cartesianSettings">
                    <div>
                        <label>Limit m·∫∑c ƒë·ªãnh cho m·ªói quota</label>
                        <input type="number" id="crosstabDefaultLimit" value="50" min="1">
                    </div>
                    <div>
                        <label>T√™n nh√≥m (Group)</label>
                        <input type="text" id="crosstabGroupName" value="cross-tab" placeholder="VD: gender_province">
                    </div>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap;" id="cartesianButtons">
                    <button class="btn btn-secondary" onclick="previewCrosstabQuotas()">üëÅÔ∏è Xem tr∆∞·ªõc t·ªï h·ª£p</button>
                    <button class="btn btn-warning" onclick="generateCrosstabQuotas()">üöÄ T·∫°o Cross-tab Quotas</button>
                </div>
            </div>

            <div class="card">
                <div class="card-title">D·ªØ li·ªáu Quota</div>
                <div class="info-box">
                    <p>üìã Copy t·ª´ Google Sheet: <strong>T√™n [TAB] Limit [TAB] Nh√≥m (t√πy ch·ªçn)</strong></p>
                    <p style="font-size: 0.85rem; opacity: 0.8;">üí° Th√™m c·ªôt th·ª© 3 ƒë·ªÉ ph√¢n nh√≥m quota (VD: age_group,
                        location, gender)</p>
                </div>
                <textarea id="quotaData" placeholder="18-29	100	age_group
30-39	100	age_group
HCMC	300	location
Hanoi	300	location
Male	150	gender
Female	150	gender"></textarea>
            </div>

            <div class="card hidden" id="createPreviewCard">
                <div class="card-title">Xem tr∆∞·ªõc</div>

                <!-- Bulk Template Apply -->
                <div class="info-box" style="margin-bottom: 16px;">
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <span>üìå √Åp d·ª•ng Logic cho c√°c m·ª•c ƒë√£ ch·ªçn:</span>
                        <select id="bulkTemplate" style="flex: 1; min-width: 180px;">
                            <option value="">-- Ch·ªçn template --</option>
                        </select>
                        <button class="btn btn-sm btn-primary" onclick="applyBulkTemplate()">‚úÖ √Åp d·ª•ng</button>
                        <button class="btn btn-sm btn-warning" onclick="mergeSelectedQuotas()">üîó G·ªôp Quota</button>
                        <button class="btn btn-sm btn-secondary" onclick="clearSelectedLogic()">üóëÔ∏è X√≥a Logic</button>
                        <button class="btn btn-sm btn-secondary" onclick="addManualQuota()">‚ûï Th√™m quota th·ªß
                            c√¥ng</button>
                    </div>
                </div>

                <table class="data-table">
                    <thead>
                        <tr>
                            <th></th>
                            <th><input type="checkbox" id="selectAllQuotas" onchange="toggleSelectAll(this)"></th>
                            <th>#</th>
                            <th style="cursor: pointer;" onclick="sortCreateQuotas('name')">T√™n Quota ‚ÜïÔ∏è</th>
                            <th style="cursor: pointer;" onclick="sortCreateQuotas('limit')">Limit ‚ÜïÔ∏è</th>
                            <th class="col-logic">Logic</th>
                            <th>Tr·∫°ng th√°i</th>
                            <th>H√†nh ƒë·ªông</th>
                        </tr>
                    </thead>
                    <tbody id="createPreviewBody"></tbody>
                </table>
            </div>

            <div class="actions">
                <button class="btn btn-secondary" onclick="parseCreateData()">üëÅÔ∏è Xem tr∆∞·ªõc</button>
                <button class="btn btn-warning hidden" id="undoBtn" onclick="undoDelete()">‚Ü©Ô∏è Ho√†n t√°c</button>
                <button class="btn btn-danger" onclick="clearPlayground()">üßπ X√≥a h·∫øt</button>
                <button class="btn btn-primary" id="createBtn" onclick="createQuotas()">‚ú® T·∫°o Quota</button>
            </div>

            <div class="card hidden" id="createResultsCard">
                <div class="card-title">K·∫øt qu·∫£</div>
                <div class="result-summary">
                    <div class="result-stat">
                        <div class="result-stat-value total-value" id="createTotal">0</div>
                        <div class="result-stat-label">T·ªïng</div>
                    </div>
                    <div class="result-stat">
                        <div class="result-stat-value success-value" id="createSuccess">0</div>
                        <div class="result-stat-label">Th√†nh c√¥ng</div>
                    </div>
                    <div class="result-stat">
                        <div class="result-stat-value error-value" id="createError">0</div>
                        <div class="result-stat-label">L·ªói</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- MANAGE TAB -->
        <div id="manageTab" class="tab-content">
            <div class="card">
                <div class="card-title warning">üìù Qu·∫£n l√Ω & Ch·ªânh s·ª≠a Quota</div>
                <button class="btn btn-secondary" onclick="loadExistingQuotas()" id="loadManageBtn">üîÑ T·∫£i danh s√°ch
                    Quota</button>
            </div>

            <div class="card hidden" id="manageCard">
                <div class="card-title">ƒêi·ªÅu ch·ªânh h√†ng lo·∫°t</div>
                <div class="adjust-controls">
                    <span>Thay ƒë·ªïi Limit:</span>
                    <select id="adjustType">
                        <option value="percent">Theo %</option>
                        <option value="add">C·ªông th√™m</option>
                        <option value="set">ƒê·∫∑t gi√° tr·ªã</option>
                    </select>
                    <input type="number" id="adjustValue" value="10" placeholder="Gi√° tr·ªã">
                    <button class="btn btn-sm btn-secondary" onclick="applyAdjustment()">√Åp d·ª•ng</button>
                    <button class="btn btn-sm btn-secondary" onclick="resetLimits()">‚Ü©Ô∏è Reset</button>
                </div>

                <div class="warning-box">
                    <p>‚ö†Ô∏è Ch·ªânh s·ª≠a Limit b√™n d∆∞·ªõi, sau ƒë√≥ nh·∫•n <strong>"C·∫≠p nh·∫≠t"</strong> ƒë·ªÉ l∆∞u thay ƒë·ªïi.</p>
                </div>

                <table class="data-table">
                    <thead>
                        <tr>
                            <th><input type="checkbox" id="selectAllManage" onchange="toggleSelectAllManage()"></th>
                            <th>ID</th>
                            <th>T√™n Quota</th>
                            <th>Limit hi·ªán t·∫°i</th>
                            <th>Limit m·ªõi</th>
                            <th>Tr·∫°ng th√°i</th>
                        </tr>
                    </thead>
                    <tbody id="manageBody"></tbody>
                </table>
            </div>

            <div class="actions hidden" id="manageActions">
                <button class="btn btn-warning" id="updateBtn" onclick="updateQuotas()">üíæ C·∫≠p nh·∫≠t Limit</button>
                <button class="btn btn-danger" id="deleteSelectedBtn" onclick="deleteSelectedFromManage()">üóëÔ∏è X√≥a quota
                    ƒë√£ ch·ªçn</button>
            </div>

            <div class="card hidden" id="updateResultsCard">
                <div class="card-title">K·∫øt qu·∫£ thao t√°c</div>
                <div class="result-summary">
                    <div class="result-stat">
                        <div class="result-stat-value total-value" id="updateTotal">0</div>
                        <div class="result-stat-label">T·ªïng</div>
                    </div>
                    <div class="result-stat">
                        <div class="result-stat-value success-value" id="updateSuccess">0</div>
                        <div class="result-stat-label">Th√†nh c√¥ng</div>
                    </div>
                    <div class="result-stat">
                        <div class="result-stat-value error-value" id="updateError">0</div>
                        <div class="result-stat-label">L·ªói</div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            let createQuotasList = [];
            let manageQuotasList = [];

            let createDeletedHistory = []; // History for undo

            // Load settings
            window.onload = () => {
                document.getElementById('surveyId').value = localStorage.getItem('alchemer_surveyId') || '';
            };

            async function alchemerAPI(path, method = 'GET', params = {}, data = null) {
                console.log(`[API Request] ${method} ${path}`, { params, data });
                try {
                    const res = await fetch('/api/alchemer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path, method, params, data })
                    });
                    const responseData = await res.json();
                    if (!responseData.result_ok) {
                        console.error(`[API Error] ${path}:`, responseData);
                    } else {
                        console.log(`[API Success] ${path}:`, responseData);
                    }
                    return responseData;
                } catch (error) {
                    console.error(`[API Fetch Error] ${path}:`, error);
                    return { result_ok: false, message: error.message };
                }
            }

            function saveSettings() {
                localStorage.setItem('alchemer_surveyId', document.getElementById('surveyId').value);
            }

            function getApiParams() {
                return {
                    surveyId: document.getElementById('surveyId').value
                };
            }

            // ========== TEMPLATE MANAGEMENT ==========
            const DEFAULT_TEMPLATES = {
                'link_panel': {
                    name: 'link = panel (Hidden Value)',
                    answerType: '2',
                    operator: '4',
                    key: '15',
                    value: 'panel'
                }
            };

            // Helper function to escape HTML
            function escapeHtml(str) {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }

            function getTemplates() {
                const saved = localStorage.getItem('quota_logic_templates');
                return saved ? { ...DEFAULT_TEMPLATES, ...JSON.parse(saved) } : { ...DEFAULT_TEMPLATES };
            }

            function saveTemplates(templates) {
                // Only save custom templates, not defaults
                const custom = {};
                for (const key in templates) {
                    if (!DEFAULT_TEMPLATES[key]) {
                        custom[key] = templates[key];
                    }
                }
                localStorage.setItem('quota_logic_templates', JSON.stringify(custom));
            }

            function refreshTemplateDropdown() {
                const select = document.getElementById('logicTemplate');
                const templates = getTemplates();
                select.innerHTML = '<option value="">-- Ch·ªçn template --</option>';
                for (const key in templates) {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = templates[key].name;
                    select.appendChild(opt);
                }
            }

            function loadTemplate() {
                const templateId = document.getElementById('logicTemplate').value;
                if (!templateId) return;

                const templates = getTemplates();
                const t = templates[templateId];
                if (!t) return;

                document.getElementById('logicAnswerType').value = t.answerType;
                document.getElementById('logicOperator').value = t.operator;
                document.getElementById('logicKey').value = t.key;
                document.getElementById('logicValue').value = t.value;

                updateLogicTypeUI();
            }

            function saveCurrentAsTemplate() {
                const name = prompt('Nh·∫≠p t√™n cho template m·ªõi:', '');
                if (!name) return;

                const id = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
                const templates = getTemplates();

                templates[id] = {
                    name: name,
                    answerType: document.getElementById('logicAnswerType').value,
                    operator: document.getElementById('logicOperator').value,
                    key: document.getElementById('logicKey').value,
                    value: document.getElementById('logicValue').value
                };

                saveTemplates(templates);
                refreshTemplateDropdown();
                document.getElementById('logicTemplate').value = id;
                alert('‚úÖ ƒê√£ l∆∞u template: ' + name);
            }

            function deleteTemplate() {
                const templateId = document.getElementById('logicTemplate').value;
                if (!templateId) return alert('Vui l√≤ng ch·ªçn template ƒë·ªÉ x√≥a');
                if (DEFAULT_TEMPLATES[templateId]) return alert('Kh√¥ng th·ªÉ x√≥a template m·∫∑c ƒë·ªãnh');

                if (!confirm('X√≥a template n√†y?')) return;

                const templates = getTemplates();
                delete templates[templateId];
                saveTemplates(templates);
                refreshTemplateDropdown();
                alert('‚úÖ ƒê√£ x√≥a template');
            }

            // Initialize templates on load
            document.addEventListener('DOMContentLoaded', refreshTemplateDropdown);

            // ========== OPTION LOOKUP ==========
            let lastLookupOptions = []; // Store for bulk operations
            let lastLookupQuestionId = '';
            let lastLookupQuestionName = '';

            async function lookupQuestionOptions() {
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');

                const questionId = document.getElementById('lookupQuestionId').value;
                if (!questionId) return alert('Vui l√≤ng nh·∫≠p Question ID');

                const resultDiv = document.getElementById('optionLookupResult');
                const tbody = document.getElementById('optionLookupBody');
                tbody.innerHTML = '<tr><td colspan="4">‚è≥ ƒêang tra c·ª©u...</td></tr>';
                resultDiv.classList.remove('hidden');

                try {
                    const data = await alchemerAPI(`survey/${surveyId}/question/${questionId}`);

                    if (!data || !data.result_ok) {
                        tbody.innerHTML = `<tr><td colspan="4" style="color: #ff5252;">‚ùå ${data.message || 'Kh√¥ng t√¨m th·∫•y Question'}</td></tr>`;
                        return;
                    }

                    const question = data.data;
                    const options = question.options || [];
                    lastLookupOptions = options;
                    lastLookupQuestionId = questionId;
                    lastLookupQuestionName = question.title?.English || question.shortname || 'Question';

                    if (options.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="4">‚ö†Ô∏è Question n√†y kh√¥ng c√≥ options (c√≥ th·ªÉ l√† Text Box ho·∫∑c Hidden Value)</td></tr>`;
                        return;
                    }

                    // Add bulk action buttons
                    let html = `<tr style="background: rgba(0,255,136,0.1);">
                    <td colspan="5">
                        <strong>üìã ${lastLookupQuestionName}</strong> (ID: ${questionId}) - ${options.length} options
                        <div style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-sm btn-primary" onclick="createAllOptionTemplates()">üíæ T·∫°o Templates cho t·∫•t c·∫£</button>
                            <button class="btn btn-sm btn-secondary" onclick="copyAllOptionIds()">üìã Copy t·∫•t c·∫£ Option IDs</button>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(255,193,7,0.1); border-radius: 8px;">
                            <strong>üîÄ G·ªôp nhi·ªÅu Options th√†nh 1 Quota:</strong>
                            <div style="margin-top: 8px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                                <input type="text" id="mergedQuotaName" placeholder="T√™n quota g·ªôp (VD: HHI > 30M)" style="flex: 1; min-width: 200px;">
                                <button class="btn btn-sm btn-warning" onclick="createMergedQuota()">‚úÖ T·∫°o Quota g·ªôp t·ª´ options ƒë√£ ch·ªçn</button>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr style="background: rgba(255,255,255,0.05);">
                    <th style="width: 40px;"><input type="checkbox" id="selectAllOptions" onchange="toggleSelectAllOptions(this)"></th>
                    <th>Option</th>
                    <th>Value</th>
                    <th>Option ID</th>
                    <th>H√†nh ƒë·ªông</th>
                </tr>`;

                    html += options.map(opt => `
                    <tr>
                        <td><input type="checkbox" class="option-checkbox" data-id="${questionId}-${opt.id}" data-name="${opt.title?.English || opt.value || opt.id}"></td>
                        <td>${opt.title?.English || opt.title || '-'}</td>
                        <td>${opt.value || '-'}</td>
                        <td><code style="background: rgba(0,217,255,0.2); padding: 4px 8px; border-radius: 4px;">${questionId}-${opt.id}</code></td>
                        <td><button class="btn btn-sm btn-primary" onclick="useOptionId('${questionId}-${opt.id}')">üìã D√πng</button></td>
                    </tr>
                `).join('');

                    tbody.innerHTML = html;

                } catch (e) {
                    tbody.innerHTML = `<tr><td colspan="4" style="color: #ff5252;">‚ùå L·ªói: ${e.message}</td></tr>`;
                    console.error('Lookup error:', e);
                }
            }

            function createAllOptionTemplates() {
                if (!lastLookupOptions.length) return alert('Ch∆∞a c√≥ options ƒë·ªÉ t·∫°o template');

                const groupName = prompt('Nh·∫≠p t√™n nh√≥m cho c√°c templates (VD: age_group):', lastLookupQuestionName.toLowerCase().replace(/\s+/g, '_'));
                if (!groupName) return;

                const templates = getTemplates();
                let created = 0;

                lastLookupOptions.forEach(opt => {
                    const optName = opt.title?.English || opt.value || opt.id;
                    const templateId = `${groupName}_${String(optName).toLowerCase().replace(/[^a-z0-9]/g, '_')}`;

                    templates[templateId] = {
                        name: `${groupName}: ${optName}`,
                        answerType: '17',
                        operator: '12', // is one of
                        key: lastLookupQuestionId,
                        value: `${lastLookupQuestionId}-${opt.id}`
                    };
                    created++;
                });

                saveTemplates(templates);
                refreshTemplateDropdown();
                refreshBulkTemplateDropdown();

                alert(`‚úÖ ƒê√£ t·∫°o ${created} templates cho nh√≥m "${groupName}"!\n\nB·∫°n c√≥ th·ªÉ ch·ªçn template n√†y trong dropdown khi t·∫°o quota.`);
            }

            function copyAllOptionIds() {
                if (!lastLookupOptions.length) return alert('Ch∆∞a c√≥ options ƒë·ªÉ copy');

                const text = lastLookupOptions.map(opt => {
                    const optName = opt.title?.English || opt.value || opt.id;
                    return `${optName}\t100\t${lastLookupQuestionName}`;
                }).join('\n');

                navigator.clipboard.writeText(text).then(() => {
                    alert(`‚úÖ ƒê√£ copy ${lastLookupOptions.length} d√≤ng v√†o clipboard!\n\nFormat: T√™n [TAB] Limit [TAB] Nh√≥m\n\nB·∫°n c√≥ th·ªÉ paste v√†o √¥ "D·ªØ li·ªáu Quota".`);
                }).catch(e => {
                    // Fallback for older browsers
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert(`‚úÖ ƒê√£ copy ${lastLookupOptions.length} d√≤ng!`);
                });
            }

            function toggleSelectAllOptions(checkbox) {
                document.querySelectorAll('.option-checkbox').forEach(cb => {
                    cb.checked = checkbox.checked;
                });
            }

            function createMergedQuota() {
                const selectedCheckboxes = document.querySelectorAll('.option-checkbox:checked');
                if (selectedCheckboxes.length < 2) return alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t 2 options ƒë·ªÉ g·ªôp');

                const quotaName = document.getElementById('mergedQuotaName').value.trim();
                if (!quotaName) return alert('Vui l√≤ng nh·∫≠p t√™n cho quota g·ªôp');

                const optionIds = [];
                const optionNames = [];
                selectedCheckboxes.forEach(cb => {
                    optionIds.push(cb.dataset.id);
                    optionNames.push(cb.dataset.name);
                });

                // Create merged logic with multiple values
                const mergedLogic = {
                    templateName: `${lastLookupQuestionName}: ${quotaName}`,
                    answerType: '17',
                    operator: '12', // is one of
                    key: lastLookupQuestionId,
                    value: optionIds // Array of option IDs
                };

                // Add to createQuotasList
                createQuotasList.push({
                    name: quotaName,
                    limit: 100,
                    group: lastLookupQuestionName,
                    status: 'pending',
                    logic: mergedLogic,
                    originalIndex: createQuotasList.length
                });

                // Also save as template
                const templates = getTemplates();
                const templateId = `merged_${quotaName.toLowerCase().replace(/[^a-z0-9]/g, '_')}`;
                templates[templateId] = {
                    name: `${lastLookupQuestionName}: ${quotaName}`,
                    answerType: '17',
                    operator: '12',
                    key: lastLookupQuestionId,
                    value: optionIds.join(',') // Store as comma-separated for template
                };
                saveTemplates(templates);
                refreshTemplateDropdown();
                refreshBulkTemplateDropdown();

                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');

                // Clear selections
                document.querySelectorAll('.option-checkbox').forEach(cb => cb.checked = false);
                document.getElementById('selectAllOptions').checked = false;
                document.getElementById('mergedQuotaName').value = '';

                alert(`‚úÖ ƒê√£ t·∫°o quota g·ªôp: "${quotaName}"\n\nG·ªìm ${optionIds.length} options:\n- ${optionNames.slice(0, 3).join('\n- ')}${optionNames.length > 3 ? '\n- ...' : ''}`);
            }

            // ========== QUESTION PICKER ==========
            let cachedQuestions = null;

            async function loadQuestionList(forceRefresh = false) {
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');

                const cacheKey = `questions_${surveyId}`;
                const cacheStatus = document.getElementById('questionCacheStatus');
                const resultDiv = document.getElementById('questionListResult');
                const tbody = document.getElementById('questionListBody');

                // Try to load from cache first
                if (!forceRefresh) {
                    const cached = localStorage.getItem(cacheKey);
                    if (cached) {
                        const { data, timestamp } = JSON.parse(cached);
                        cachedQuestions = data;
                        cacheStatus.textContent = `üì¶ T·ª´ cache (${new Date(timestamp).toLocaleString()})`;
                        renderQuestionList(data);
                        resultDiv.classList.remove('hidden');
                        return;
                    }
                }

                // Load from API
                tbody.innerHTML = '<tr><td colspan="5">‚è≥ ƒêang t·∫£i t·ª´ API...</td></tr>';
                resultDiv.classList.remove('hidden');

                try {
                    const data = await alchemerAPI(`survey/${surveyId}/question`);

                    if (!data || !data.result_ok) {
                        tbody.innerHTML = `<tr><td colspan="5" style="color: #ff5252;">‚ùå ${data.message || 'L·ªói'}</td></tr>`;
                        return;
                    }

                    // Filter only questions with potential options (Radio, Checkbox, Dropdown, etc.)
                    const questions = (data.data || []).filter(q =>
                        ['RADIO', 'CHECKBOX', 'MENU', 'SELECT', 'RANK'].includes(q.type) ||
                        q.type?.includes('RADIO') || q.type?.includes('CHECKBOX')
                    );

                    // Save to cache
                    localStorage.setItem(cacheKey, JSON.stringify({
                        data: questions,
                        timestamp: Date.now()
                    }));
                    cachedQuestions = questions;
                    cacheStatus.textContent = `‚úÖ M·ªõi t·∫£i (${questions.length} questions)`;

                    renderQuestionList(questions);

                } catch (e) {
                    tbody.innerHTML = `<tr><td colspan="5" style="color: #ff5252;">‚ùå L·ªói: ${e.message}</td></tr>`;
                    console.error('Load error:', e);
                }
            }

            function renderQuestionList(questions) {
                const tbody = document.getElementById('questionListBody');

                if (questions.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5">‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Questions c√≥ options</td></tr>';
                    return;
                }

                tbody.innerHTML = questions.map(q => {
                    const qName = escapeHtml(q.title?.English || q.shortname || 'Question');
                    return `
                <tr>
                    <td><input type="checkbox" class="question-checkbox" data-id="${q.id}" data-name="${qName}" data-type="${q.type}" onchange="updateSelectedCount()"></td>
                    <td><code>${q.id}</code></td>
                    <td>${qName}</td>
                    <td><span class="status status-pending" style="font-size: 0.75rem;">${q.type}</span></td>
                    <td>--</td>
                </tr>`;
                }).join('');
            }

            function toggleSelectAllQuestions(checkbox) {
                document.querySelectorAll('.question-checkbox').forEach(cb => {
                    cb.checked = checkbox.checked;
                });
                updateSelectedCount();
            }

            function updateSelectedCount() {
                const count = document.querySelectorAll('.question-checkbox:checked').length;
                document.getElementById('selectedQuestionsCount').textContent = `${count} ƒë√£ ch·ªçn`;
            }

            async function addSelectedQuestionsToPreview() {
                const { surveyId } = getApiParams();
                const selectedCheckboxes = document.querySelectorAll('.question-checkbox:checked');

                if (selectedCheckboxes.length === 0) return alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 Question');

                const btn = event.target;
                btn.disabled = true;
                btn.textContent = '‚è≥ ƒêang t·∫£i options...';

                let newQuotas = [];
                let templates = getTemplates();

                for (const cb of selectedCheckboxes) {
                    const questionId = cb.dataset.id;
                    const questionName = cb.dataset.name;

                    try {
                        const data = await alchemerAPI(`survey/${surveyId}/question/${questionId}`);

                        if (data.result_ok && data.data.options) {
                            const groupName = questionName.toLowerCase().replace(/[^a-z0-9]/g, '_');

                            data.data.options.forEach(opt => {
                                const optName = opt.title?.English || opt.value || opt.id;
                                const optionId = `${questionId}-${opt.id}`;
                                const templateId = `${groupName}_${String(optName).toLowerCase().replace(/[^a-z0-9]/g, '_')}`;

                                // Create template for this option
                                templates[templateId] = {
                                    name: `${questionName}: ${optName}`,
                                    answerType: '17',
                                    operator: '12',
                                    key: questionId,
                                    value: optionId
                                };

                                // Add quota with logic already set
                                newQuotas.push({
                                    name: optName,
                                    limit: 100,
                                    group: questionName,
                                    status: 'pending',
                                    logic: {
                                        templateName: `${questionName}: ${optName}`,
                                        answerType: '17',
                                        operator: '12',
                                        key: questionId,
                                        value: optionId
                                    },
                                    originalIndex: createQuotasList.length + newQuotas.length
                                });
                            });
                        }
                    } catch (e) {
                        console.error(`Error loading question ${questionId}:`, e);
                    }

                    // Small delay to avoid rate limiting
                    await new Promise(r => setTimeout(r, 200));
                }

                // Save templates
                saveTemplates(templates);
                refreshTemplateDropdown();

                // Add to preview
                createQuotasList = [...createQuotasList, ...newQuotas];
                refreshBulkTemplateDropdown();
                renderCreatePreview();

                document.getElementById('createPreviewCard').classList.remove('hidden');
                btn.disabled = false;
                btn.textContent = '‚úÖ Th√™m Questions ƒë√£ ch·ªçn v√†o Xem tr∆∞·ªõc';

                // Uncheck all
                document.querySelectorAll('.question-checkbox').forEach(cb => cb.checked = false);
                document.getElementById('selectAllQuestions').checked = false;
                updateSelectedCount();

                alert(`‚úÖ ƒê√£ th√™m ${newQuotas.length} quota t·ª´ ${selectedCheckboxes.length} Questions!\n\nLogic ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông g√°n cho m·ªói quota.`);
            }

            // Quick Add functions for common question groups
            const COMMON_QUESTIONS = {
                93: 'age_group',
                75: 'family_income',
                87: 'province',
                150: 'gender'
            };

            async function quickAddQuestion(questionId, groupName) {
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');

                const btn = event.target;
                const originalText = btn.textContent;
                btn.disabled = true;
                btn.textContent = '‚è≥...';

                try {
                    const data = await alchemerAPI(`survey/${surveyId}/question/${questionId}`);

                    if (!data || !data.result_ok || !data.data.options) {
                        alert(`‚ùå Kh√¥ng t√¨m th·∫•y Question ${questionId} ho·∫∑c kh√¥ng c√≥ options`);
                        btn.disabled = false;
                        btn.textContent = originalText;
                        return;
                    }

                    const questionName = data.data.title?.English || groupName;
                    let templates = getTemplates();
                    let newQuotas = [];

                    data.data.options.forEach(opt => {
                        const optName = opt.title?.English || opt.value || opt.id;
                        const optionId = `${questionId}-${opt.id}`;
                        const templateId = `${groupName}_${String(optName).toLowerCase().replace(/[^a-z0-9]/g, '_')}`;

                        templates[templateId] = {
                            name: `${groupName}: ${optName}`,
                            answerType: '17',
                            operator: '12',
                            key: String(questionId),
                            value: optionId
                        };

                        newQuotas.push({
                            name: optName,
                            limit: 100,
                            group: groupName,
                            status: 'pending',
                            logic: {
                                templateName: `${groupName}: ${optName}`,
                                answerType: '17',
                                operator: '12',
                                key: String(questionId),
                                value: optionId
                            },
                            originalIndex: createQuotasList.length + newQuotas.length
                        });
                    });

                    saveTemplates(templates);
                    refreshTemplateDropdown();
                    createQuotasList = [...createQuotasList, ...newQuotas];
                    refreshBulkTemplateDropdown();
                    renderCreatePreview();
                    document.getElementById('createPreviewCard').classList.remove('hidden');

                    btn.disabled = false;
                    btn.textContent = originalText;
                    alert(`‚úÖ ƒê√£ th√™m ${newQuotas.length} quota cho nh√≥m "${groupName}"!`);

                } catch (e) {
                    console.error('Quick add error:', e);
                    alert(`‚ùå L·ªói: ${e.message}`);
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            }

            async function quickAddMultipleQuestions(questionIds) {
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');

                const btn = event.target;
                const originalText = btn.textContent;
                btn.disabled = true;
                btn.textContent = '‚è≥ ƒêang t·∫£i...';

                let totalAdded = 0;
                let templates = getTemplates();
                let newQuotas = [];

                for (const questionId of questionIds) {
                    const groupName = COMMON_QUESTIONS[questionId] || `question_${questionId}`;

                    try {
                        const data = await alchemerAPI(`survey/${surveyId}/question/${questionId}`);

                        if (data.result_ok && data.data.options) {
                            data.data.options.forEach(opt => {
                                const optName = opt.title?.English || opt.value || opt.id;
                                const optionId = `${questionId}-${opt.id}`;
                                const templateId = `${groupName}_${String(optName).toLowerCase().replace(/[^a-z0-9]/g, '_')}`;

                                templates[templateId] = {
                                    name: `${groupName}: ${optName}`,
                                    answerType: '17',
                                    operator: '12',
                                    key: String(questionId),
                                    value: optionId
                                };

                                newQuotas.push({
                                    name: optName,
                                    limit: 100,
                                    group: groupName,
                                    status: 'pending',
                                    logic: {
                                        templateName: `${groupName}: ${optName}`,
                                        answerType: '17',
                                        operator: '12',
                                        key: String(questionId),
                                        value: optionId
                                    },
                                    originalIndex: createQuotasList.length + newQuotas.length
                                });
                                totalAdded++;
                            });
                        }
                    } catch (e) {
                        console.error(`Error loading question ${questionId}:`, e);
                    }

                    await new Promise(r => setTimeout(r, 200));
                }

                saveTemplates(templates);
                refreshTemplateDropdown();
                createQuotasList = [...createQuotasList, ...newQuotas];
                refreshBulkTemplateDropdown();
                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');

                btn.disabled = false;
                btn.textContent = originalText;
                alert(`‚úÖ ƒê√£ th√™m ${totalAdded} quota t·ª´ ${questionIds.length} nh√≥m!\n\n- age_group\n- family_income\n- province\n- gender`);
            }

            function useOptionId(optionId) {
                document.getElementById('logicAnswerType').value = '17';
                document.getElementById('logicOperator').value = '12';
                document.getElementById('logicKey').value = optionId.split('-')[0];
                document.getElementById('logicValue').value = optionId;
                updateLogicTypeUI();
                alert('‚úÖ ƒê√£ ƒëi·ªÅn Option ID: ' + optionId);
            }

            function updateLogicUI() {
                updateLogicPreview();
            }

            function updateLogicTypeUI() {
                const answerType = document.getElementById('logicAnswerType').value;
                const keyLabel = document.getElementById('logicKeyLabel');
                const keyHelp = document.getElementById('logicKeyHelp');
                const valueLabel = document.getElementById('logicValueLabel');
                const valueHelp = document.getElementById('logicValueHelp');
                const valueInput = document.getElementById('logicValue');
                const operatorSelect = document.getElementById('logicOperator');

                if (answerType === '17') {
                    // Question Option
                    keyLabel.textContent = 'Question ID';
                    keyHelp.textContent = 'üí° ID c·ªßa c√¢u h·ªèi (VD: 93 cho c√¢u age_group)';
                    valueLabel.textContent = 'Option ID (QuestionID-OptionID)';
                    valueHelp.textContent = 'üí° Format: 93-10500 (xem API ƒë·ªÉ l·∫•y Option ID)';
                    valueInput.placeholder = 'VD: 93-10500';
                    // Set default operator to "is one of"
                    operatorSelect.value = '12';
                } else {
                    // Hidden Value
                    keyLabel.textContent = 'Hidden Value ID';
                    keyHelp.textContent = 'üí° ID c·ªßa Hidden Value (VD: 15 cho "link")';
                    valueLabel.textContent = 'Gi√° tr·ªã (Value)';
                    valueHelp.textContent = 'üí° Gi√° tr·ªã text ƒë·ªÉ so s√°nh';
                    valueInput.placeholder = 'VD: panel';
                    // Set default operator to "is exactly equal to"
                    operatorSelect.value = '4';
                }
                updateLogicPreview();
            }

            function updateLogicPreview() {
                const operator = document.getElementById('logicOperator');
                const operatorText = operator.options[operator.selectedIndex].text.split(' (')[0];
                const logicKey = document.getElementById('logicKey').value || '?';
                const logicValue = document.getElementById('logicValue').value || '?';
                const preview = document.getElementById('logicPreview');
                const answerType = document.getElementById('logicAnswerType').value;

                const isAnsweredOp = ['20', '21'].includes(operator.value);
                const typeLabel = answerType === '17' ? 'Q' : 'HV';

                if (isAnsweredOp) {
                    preview.textContent = `Logic: ${typeLabel}[${logicKey}] ${operatorText}`;
                } else {
                    preview.textContent = `Logic: ${typeLabel}[${logicKey}] ${operatorText} "${logicValue}"`;
                }
            }

            // Update preview on input change
            document.addEventListener('DOMContentLoaded', () => {
                ['logicAnswerType', 'logicOperator', 'logicKey', 'logicValue'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.addEventListener('change', updateLogicPreview);
                    if (el) el.addEventListener('input', updateLogicPreview);
                });
            });

            function switchTab(tab) {
                document.querySelectorAll('.tab').forEach((t, i) => {
                    t.classList.toggle('active',
                        (tab === 'create' && i === 0) ||
                        (tab === 'manage' && i === 1));
                });
                document.getElementById('createTab').classList.toggle('active', tab === 'create');
                document.getElementById('manageTab').classList.toggle('active', tab === 'manage');
            }

            // ========== CREATE ==========
            function parseCreateData() {
                const data = document.getElementById('quotaData').value.trim();
                if (!data) return alert('Vui l√≤ng d√°n d·ªØ li·ªáu quota');

                createQuotasList = data.split('\n').map((line, idx) => {
                    const parts = line.split('\t');
                    return parts.length >= 2 ? {
                        name: parts[0].trim(),
                        limit: parseInt(parts[1]) || 100,
                        group: parts[2]?.trim() || 'Ch∆∞a ph√¢n nh√≥m',
                        status: 'pending',
                        logic: null,
                        originalIndex: idx
                    } : null;
                }).filter(Boolean);

                createDeletedHistory = [];
                updateUndoVisibility();
                refreshBulkTemplateDropdown();

                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');
            }

            function refreshBulkTemplateDropdown() {
                const select = document.getElementById('bulkTemplate');
                const templates = getTemplates();
                select.innerHTML = '<option value="">-- Ch·ªçn template --</option>';
                for (const key in templates) {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = templates[key].name;
                    select.appendChild(opt);
                }
            }

            function getGroups() {
                const groups = {};
                createQuotasList.forEach((q, i) => {
                    if (!groups[q.group]) groups[q.group] = [];
                    groups[q.group].push({ ...q, index: i });
                });
                return groups;
            }

            // ========== RENDER PREVIEW ==========
            let collapsedGroups = new Set();

            function toggleGroup(groupName) {
                if (collapsedGroups.has(groupName)) collapsedGroups.delete(groupName);
                else collapsedGroups.add(groupName);
                renderCreatePreview();
            }

            function renderCreatePreview() {
                const groups = getGroups();
                const groupNames = Object.keys(groups);

                let html = '';
                groupNames.forEach((groupName, gIdx) => {
                    const items = groups[groupName];
                    const safeGroupName = escapeHtml(groupName);
                    const isCollapsed = collapsedGroups.has(groupName);
                    const colorIdx = gIdx % 6;

                    // Group header
                    html += `<tr class="group-header group-color-${colorIdx}">
                    <td colspan="2" style="text-align: center;" class="group-connector-cell">
                        <input type="checkbox" class="group-checkbox" data-group="${safeGroupName}" onchange="toggleGroupSelect(this, '${safeGroupName}')">
                        ${!isCollapsed ? '<div class="group-connector-line"></div>' : ''}
                    </td>
                    <td colspan="6">
                        <div class="group-info">
                            <div class="group-toggle ${isCollapsed ? 'collapsed' : ''}" onclick="toggleGroup('${safeGroupName}')" style="margin-left: -5px;">‚ñº</div>
                            <span style="cursor: pointer; display: flex; align-items: center; gap: 8px;" onclick="toggleGroup('${safeGroupName}')">
                                <span style="font-size: 1.2rem;">üìÅ</span> ${safeGroupName}
                            </span>
                            <span style="font-size: 0.8rem; color: #8892b0; font-weight: normal;">(${items.length} m·ª•c)</span>
                        </div>
                    </td>
                </tr>`;

                    // Group items
                    items.forEach((q, i) => {
                        // Build detailed logic tooltip with labels
                        let logicTooltip = '';
                        let logicDisplay = '';

                        // Helper function to get question/option label
                        const getQuestionLabel = (qId) => {
                            const found = cachedQuestionsForCustom.find(cq => cq.id == qId);
                            return found ? found.title : `Q${qId}`;
                        };
                        const getOptionLabel = (qId, optId) => {
                            const found = cachedQuestionsForCustom.find(cq => cq.id == qId);
                            if (found && found.options) {
                                const opt = found.options.find(o => o.id === optId || o.id === String(optId));
                                if (opt) return opt.title;
                            }
                            return optId;
                        };
                        const formatRuleTooltip = (r) => {
                            const qLabel = getQuestionLabel(r.input_value);
                            const opLabel = r.operator === '12' ? 'is one of' : r.operator === '4' ? '=' : r.operator === '20' ? 'answered' : r.operator === '21' ? 'not answered' : r.operator;
                            let valLabels = '';
                            if (Array.isArray(r.answers_values)) {
                                valLabels = r.answers_values.map(v => getOptionLabel(r.input_value, v)).join(', ');
                            } else {
                                valLabels = getOptionLabel(r.input_value, r.answers_values);
                            }
                            return `${qLabel} ${opLabel} [${valLabels}]`;
                        };

                        if (q.logic) {
                            if (q.logic.isCustomGroups && q.logic.groups) {
                                // Custom groups logic
                                const groupsInfo = q.logic.groups.map((g, gIdx) => {
                                    const rulesInfo = g.rules.map((r, rIdx) => {
                                        const ruleText = formatRuleTooltip(r);
                                        return `  ${ruleText}${r.next_operator ? ' ' + r.next_operator.toUpperCase() : ''}`;
                                    }).join('\n');
                                    return `Group ${gIdx + 1}:\n${rulesInfo}${g.next_operator ? '\n-- ' + g.next_operator.toUpperCase() + ' --' : ''}`;
                                }).join('\n');
                                logicTooltip = groupsInfo;
                                logicDisplay = `<div class="logic-tag" style="cursor: help;" title="${escapeHtml(logicTooltip)}">üîó ${q.logic.groups.length} group(s), ${q.logic.groups.reduce((s, g) => s + g.rules.length, 0)} rules</div>`;
                            } else if (q.logic.isMultiRule && q.logic.rules) {
                                // Cross-tab rules
                                const rulesInfo = q.logic.rules.map((r, idx) => {
                                    const ruleText = formatRuleTooltip(r);
                                    return `${ruleText}${r.next_operator ? ' ' + r.next_operator.toUpperCase() : ''}`;
                                }).join('\n');
                                logicTooltip = rulesInfo;
                                logicDisplay = `<div class="logic-tag" style="cursor: help;" title="${escapeHtml(logicTooltip)}">üîÄ ${q.logic.rules.length} ƒëi·ªÅu ki·ªán</div>`;
                            } else if (q.logic.key) {
                                // Single rule logic
                                const qLabel = getQuestionLabel(q.logic.key);
                                let valLabels = '';
                                if (Array.isArray(q.logic.value)) {
                                    valLabels = q.logic.value.map(v => getOptionLabel(q.logic.key, v)).join(', ');
                                } else {
                                    valLabels = getOptionLabel(q.logic.key, q.logic.value);
                                }
                                logicTooltip = `${qLabel} = [${valLabels}]`;
                                logicDisplay = `<div class="logic-tag" style="cursor: help;" title="${escapeHtml(logicTooltip)}">${escapeHtml(q.logic.templateName || 'Single rule')}</div>`;
                            } else {
                                logicDisplay = `<div class="logic-tag" title="${escapeHtml(q.logic.templateName || '')}">${escapeHtml(q.logic.templateName || 'Custom')}</div>`;
                            }
                        } else {
                            logicDisplay = '<span style="color: #444; font-size: 0.75rem;">(Tr·ªëng logic)</span>';
                        }

                        const isLast = i === items.length - 1;
                        const hiddenClass = isCollapsed ? 'is-hidden' : '';

                        html += `<tr id="create-row-${q.index}" class="draggable-row child-row group-color-${colorIdx} ${hiddenClass} ${isLast ? 'last-child' : ''}" data-index="${q.index}">
                        <td class="drag-handle" style="cursor: grab;">‚†ø</td>
                        <td class="tree-cell">
                            <div class="tree-line-v"></div>
                            <div class="tree-line-h"></div>
                            <input type="checkbox" class="quota-checkbox" data-index="${q.index}" data-group="${safeGroupName}">
                        </td>
                        <td><span style="color: #555; font-size: 0.8rem;">#${q.index + 1}</span></td>
                        <td><input type="text" value="${escapeHtml(q.name)}" onchange="updateCreateName(${q.index}, this.value)" style="width: 100%; border: none; background: transparent; padding: 4px 8px; font-weight: 500;"></td>
                        <td><input type="number" value="${q.limit}" onchange="updateCreateLimit(${q.index}, this.value)" style="width: 70px; border: none; background: transparent; padding: 4px 8px;"></td>
                        <td>
                            <div style="display: flex; align-items: center; gap: 4px;">
                                ${logicDisplay}
                                <button class="btn btn-sm" style="padding: 2px 6px; background: transparent; color: #00d9ff; font-size: 0.7rem;" onclick="viewLogicDetail(${q.index})" title="Xem/S·ª≠a logic">‚úèÔ∏è</button>
                            </div>
                        </td>
                        <td style="text-align: center;"><span class="status status-pending" style="background: transparent;">‚è≥</span></td>
                        <td>
                            <div style="display: flex; gap: 4px; justify-content: flex-end;">
                                <button class="btn btn-sm" style="padding: 2px 8px; background: transparent; color: #00d9ff; opacity: 0.7;" onclick="duplicateCreateRow(${q.index})" title="Copy d√≤ng n√†y">üìã</button>
                                <button class="btn btn-sm btn-danger" style="padding: 2px 8px; background: transparent; color: #ff5252; opacity: 0.6;" onclick="deleteCreateRow(${q.index})" title="X√≥a">üóëÔ∏è</button>
                            </div>
                        </td>
                    </tr>`;
                    });
                });

                document.getElementById('createPreviewBody').innerHTML = html;
                initSortable();
            }

            function initSortable() {
                const el = document.getElementById('createPreviewBody');
                if (window.createSortable) window.createSortable.destroy();

                window.createSortable = new Sortable(el, {
                    animation: 150,
                    handle: '.drag-handle',
                    draggable: '.draggable-row',
                    ghostClass: 'sortable-ghost',
                    onEnd: function (evt) {
                        const newOrder = [];
                        const rows = el.querySelectorAll('.draggable-row');
                        rows.forEach(row => {
                            newOrder.push(createQuotasList[parseInt(row.dataset.index)]);
                        });
                        createQuotasList = newOrder;
                        // Re-render to update index numbers and internal references
                        renderCreatePreview();
                    }
                });
            }

            function toggleGroupSelect(checkbox, groupName) {
                document.querySelectorAll(`.quota-checkbox[data-group="${groupName}"]`).forEach(cb => {
                    cb.checked = checkbox.checked;
                });
            }

            function applyGroupTemplate(groupName) {
                const select = document.querySelector(`.group-template[data-group="${groupName}"]`);
                const templateId = select.value;
                if (!templateId) return alert('Vui l√≤ng ch·ªçn template');

                const templates = getTemplates();
                const t = templates[templateId];
                if (!t) return;

                let count = 0;
                createQuotasList.forEach((q, i) => {
                    if (q.group === groupName) {
                        q.logic = {
                            templateName: t.name,
                            answerType: t.answerType,
                            operator: t.operator,
                            key: t.key,
                            value: t.value
                        };
                        count++;
                    }
                });

                renderCreatePreview();
                alert(`‚úÖ ƒê√£ √°p d·ª•ng "${t.name}" cho ${count} quota trong nh√≥m "${groupName}"`);
            }

            function toggleSelectAll(checkbox) {
                document.querySelectorAll('.quota-checkbox').forEach(cb => {
                    cb.checked = checkbox.checked;
                });
            }

            function getSelectedIndices() {
                const indices = [];
                document.querySelectorAll('.quota-checkbox:checked').forEach(cb => {
                    indices.push(parseInt(cb.dataset.index));
                });
                return indices;
            }

            function applyBulkTemplate() {
                const templateId = document.getElementById('bulkTemplate').value;
                if (!templateId) return alert('Vui l√≤ng ch·ªçn template');

                const indices = getSelectedIndices();
                if (indices.length === 0) return alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 quota');

                const templates = getTemplates();
                const t = templates[templateId];
                if (!t) return alert('Template kh√¥ng t·ªìn t·∫°i');

                indices.forEach(i => {
                    createQuotasList[i].logic = {
                        templateName: t.name,
                        answerType: t.answerType,
                        operator: t.operator,
                        key: t.key,
                        value: t.value
                    };
                });

                renderCreatePreview();
                document.getElementById('selectAllQuotas').checked = false;
                alert(`‚úÖ ƒê√£ √°p d·ª•ng "${t.name}" cho ${indices.length} quota`);
            }

            function clearSelectedLogic() {
                const indices = getSelectedIndices();
                if (indices.length === 0) return alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 quota');

                indices.forEach(i => {
                    createQuotasList[i].logic = null;
                });

                renderCreatePreview();
                document.getElementById('selectAllQuotas').checked = false;
                alert(`‚úÖ ƒê√£ x√≥a logic c·ªßa ${indices.length} quota`);
            }

            function mergeSelectedQuotas() {
                const indices = getSelectedIndices().sort((a, b) => b - a); // Sort descending to splice safely
                if (indices.length < 2) return alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t 2 quota ƒë·ªÉ g·ªôp');

                const selectedItems = indices.map(i => createQuotasList[i]);

                // Check if all selected items have simple logic from the same question
                const questionIds = new Set();
                const optionIds = [];
                const names = [];
                let groupName = selectedItems[0].group;

                for (const item of selectedItems) {
                    if (!item.logic || item.logic.answerType !== '17') {
                        return alert(`Quota "${item.name}" kh√¥ng c√≥ logic Question ho·∫∑c logic kh√¥ng h·ª£p l·ªá ƒë·ªÉ g·ªôp.`);
                    }
                    questionIds.add(item.logic.key);

                    // Handle both single value and array values (already merged)
                    if (Array.isArray(item.logic.value)) {
                        optionIds.push(...item.logic.value);
                    } else if (typeof item.logic.value === 'string' && item.logic.value.includes(',')) {
                        optionIds.push(...item.logic.value.split(','));
                    } else {
                        optionIds.push(item.logic.value);
                    }
                    names.push(item.name);
                }

                if (questionIds.size > 1) {
                    return alert('Ch·ªâ c√≥ th·ªÉ g·ªôp c√°c quota thu·ªôc c√πng m·ªôt Question ID.');
                }

                const newName = prompt('Nh·∫≠p t√™n cho quota g·ªôp m·ªõi:', names.join(' + '));
                if (!newName) return;

                const qId = Array.from(questionIds)[0];
                const mergedLogic = {
                    templateName: `Merged: ${newName}`,
                    answerType: '17',
                    operator: '12', // is one of
                    key: qId,
                    value: optionIds // Keep as array
                };

                // 1. Remove old items
                indices.forEach(i => createQuotasList.splice(i, 1));

                // 2. Add new merged item
                createQuotasList.push({
                    name: newName,
                    limit: 100,
                    group: groupName,
                    status: 'pending',
                    logic: mergedLogic,
                    originalIndex: createQuotasList.length
                });

                renderCreatePreview();
                alert(`‚úÖ ƒê√£ g·ªôp ${selectedItems.length} quota th√†nh "${newName}"`);
            }

            function updateCreateName(index, value) {
                createQuotasList[index].name = value.trim();
            }

            function updateCreateLimit(index, value) {
                createQuotasList[index].limit = parseInt(value) || 0;
            }

            function deleteCreateRow(index) {
                const item = createQuotasList.splice(index, 1)[0];
                createDeletedHistory.push({ item, index });
                renderCreatePreview();
                updateUndoVisibility();
                if (createQuotasList.length === 0) {
                    document.getElementById('createPreviewCard').classList.add('hidden');
                }
            }

            function duplicateCreateRow(index) {
                const original = createQuotasList[index];
                if (!original) return;

                // Deep clone the quota
                const duplicate = JSON.parse(JSON.stringify(original));
                duplicate.name = original.name + ' (copy)';
                duplicate.originalIndex = createQuotasList.length;
                duplicate.status = 'pending';

                // Insert right after the original
                createQuotasList.splice(index + 1, 0, duplicate);
                renderCreatePreview();
            }

            let createSortOrder = { name: 1, limit: 1 };
            function sortCreateQuotas(criteria) {
                const direction = createSortOrder[criteria];
                createQuotasList.sort((a, b) => {
                    if (criteria === 'limit') return (a.limit - b.limit) * direction;
                    return a.name.localeCompare(b.name) * direction;
                });
                createSortOrder[criteria] *= -1; // Toggle for next click
                renderCreatePreview();
            }

            function moveCreateRow(index, direction) {
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= createQuotasList.length) return;

                // Swap items
                const temp = createQuotasList[index];
                createQuotasList[index] = createQuotasList[newIndex];
                createQuotasList[newIndex] = temp;

                renderCreatePreview();
            }

            function addManualQuota() {
                const name = prompt('Nh·∫≠p t√™n quota:', 'New Quota');
                if (!name) return;

                const limit = parseInt(prompt('Nh·∫≠p limit:', '100')) || 100;
                const group = prompt('Nh·∫≠p nh√≥m (ƒë·ªÉ tr·ªëng n·∫øu kh√¥ng c√≥):', '') || 'Th·ªß c√¥ng';

                createQuotasList.push({
                    name: name,
                    limit: limit,
                    group: group,
                    status: 'pending',
                    logic: null,
                    originalIndex: createQuotasList.length
                });

                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');
            }

            function undoDelete() {
                if (createDeletedHistory.length === 0) return;
                const last = createDeletedHistory.pop();
                createQuotasList.splice(last.index, 0, last.item);
                renderCreatePreview();
                updateUndoVisibility();
                document.getElementById('createPreviewCard').classList.remove('hidden');
            }

            function updateUndoVisibility() {
                const btn = document.getElementById('undoBtn');
                if (createDeletedHistory.length > 0) {
                    btn.classList.remove('hidden');
                    btn.innerHTML = `‚Ü©Ô∏è Ho√†n t√°c (${createDeletedHistory.length})`;
                } else {
                    btn.classList.add('hidden');
                }
            }

            async function createQuotas() {
                if (!createQuotasList.length) { parseCreateData(); if (!createQuotasList.length) return; }
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');
                saveSettings();

                const btn = document.getElementById('createBtn');
                btn.disabled = true; btn.innerHTML = '<span class="spinner"></span> ƒêang t·∫°o...';

                const globalEnableLogic = document.getElementById('enableLogic').checked;
                const globalLogicAnswerType = document.getElementById('logicAnswerType').value;
                const globalLogicOperator = document.getElementById('logicOperator').value;
                const globalLogicKey = document.getElementById('logicKey').value;
                const globalLogicValue = document.getElementById('logicValue').value;

                let success = 0, errors = 0;

                for (let i = 0; i < createQuotasList.length; i++) {
                    const q = createQuotasList[i];
                    try {
                        // Use individual logic if set, otherwise use global logic
                        let useLogic = q.logic || (globalEnableLogic && globalLogicKey ? {
                            answerType: globalLogicAnswerType,
                            operator: globalLogicOperator,
                            key: globalLogicKey,
                            value: globalLogicValue
                        } : null);

                        const params = {
                            _method: 'PUT',
                            name: q.name,
                            limit: q.limit
                        };

                        if (useLogic && (useLogic.key || useLogic.isMultiRule || useLogic.isCustomGroups)) {
                            let groupsObj;

                            // Check if this is a custom groups quota (full API structure)
                            if (useLogic.isCustomGroups && useLogic.groups) {
                                groupsObj = useLogic.groups;
                            }
                            // Check if this is a cross-tab quota with multiple rules
                            else if (useLogic.isMultiRule && useLogic.rules) {
                                // Cross-tab: multiple rules in single group
                                groupsObj = [{
                                    rules: useLogic.rules,
                                    next_operator: ''
                                }];
                            } else {
                                // Regular single-rule quota
                                const isAnsweredOp = ['20', '21'].includes(useLogic.operator);

                                let answersValues;
                                if (isAnsweredOp) {
                                    answersValues = "";
                                } else if (useLogic.answerType === '17') {
                                    // Check if value is already an array (merged quota)
                                    if (Array.isArray(useLogic.value)) {
                                        answersValues = useLogic.value;
                                    } else {
                                        answersValues = [useLogic.value];
                                    }
                                } else {
                                    answersValues = useLogic.value;
                                }

                                groupsObj = [{
                                    rules: [{
                                        input_value: useLogic.key,
                                        operator: useLogic.operator,
                                        answers_type: useLogic.answerType,
                                        answers_values: answersValues,
                                        next_operator: ''
                                    }],
                                    next_operator: ''
                                }];
                            }
                            params.groups = JSON.stringify(groupsObj);
                        }

                        const data = await alchemerAPI(`survey/${surveyId}/quotas`, 'POST', params);

                        const row = document.querySelector(`#create-row-${i} .status`);

                        if (data && data.result_ok) {
                            row.className = 'status status-success';
                            row.textContent = '‚úÖ OK';
                            success++;
                        } else {
                            row.className = 'status status-error';
                            row.textContent = `‚ùå ${data?.message || 'L·ªói API'}`;
                            console.error('API Error:', data);
                            errors++;
                        }
                    } catch (e) {
                        const row = document.querySelector(`#create-row-${i} .status`);
                        row.className = 'status status-error';
                        row.textContent = '‚ùå L·ªói m·∫°ng/CORS';
                        console.error('Fetch error:', e);
                        errors++;
                    }
                    await new Promise(r => setTimeout(r, 300));
                }

                document.getElementById('createTotal').textContent = createQuotasList.length;
                document.getElementById('createSuccess').textContent = success;
                document.getElementById('createError').textContent = errors;
                document.getElementById('createResultsCard').classList.remove('hidden');
                btn.disabled = false; btn.innerHTML = '‚ú® T·∫°o Quota';
            }

            // ========== MANAGE ==========
            async function loadExistingQuotas() {
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');
                saveSettings();

                const btn = document.getElementById('loadManageBtn');
                btn.disabled = true; btn.innerHTML = '<span class="spinner"></span> ƒêang t·∫£i...';

                try {
                    const data = await alchemerAPI(`survey/${surveyId}/quotas`);

                    if (data && data.result_ok) {
                        // API returns quotas in data.quotas or data.data depending on version
                        const quotas = data.quotas || data.data || [];
                        manageQuotasList = quotas.map(q => ({ ...q, originalLimit: parseInt(q.limit), newLimit: parseInt(q.limit), status: '' }));
                        renderManageTable();
                        document.getElementById('manageCard').classList.remove('hidden');
                        document.getElementById('manageActions').classList.remove('hidden');
                    } else alert('L·ªói: ' + (data?.message || 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch'));
                } catch (e) { alert('L·ªói: ' + e.message); }

                btn.disabled = false; btn.innerHTML = 'üîÑ T·∫£i danh s√°ch Quota';
            }

            function renderManageTable() {
                document.getElementById('manageBody').innerHTML = manageQuotasList.map((q, i) => {
                    const change = q.newLimit - q.originalLimit;
                    const changeText = change !== 0 ? `<span class="change-indicator ${change > 0 ? 'change-up' : 'change-down'}">${change > 0 ? '+' : ''}${change}</span>` : '';
                    const statusClass = change !== 0 ? 'status-modified' : '';
                    const statusText = q.status || (change !== 0 ? 'üìù ƒê√£ s·ª≠a' : '');
                    return `<tr id="manage-row-${i}">
                    <td><input type="checkbox" class="manage-check" value="${q.id}" data-index="${i}"></td>
                    <td>${q.id}</td>
                    <td>${q.name}</td>
                    <td>${q.originalLimit}</td>
                    <td><input type="number" value="${q.newLimit}" onchange="updateNewLimit(${i}, this.value)">${changeText}</td>
                    <td><span class="status ${statusClass}">${statusText}</span></td>
                </tr>`;
                }).join('');
            }

            function updateNewLimit(index, value) {
                manageQuotasList[index].newLimit = parseInt(value) || 0;
                renderManageTable();
            }

            function applyAdjustment() {
                const type = document.getElementById('adjustType').value;
                const value = parseFloat(document.getElementById('adjustValue').value) || 0;

                const checked = document.querySelectorAll('.manage-check:checked');
                const indices = checked.length > 0 ? Array.from(checked).map(c => parseInt(c.dataset.index)) : manageQuotasList.map((_, i) => i);

                indices.forEach(i => {
                    const q = manageQuotasList[i];
                    if (type === 'percent') q.newLimit = Math.round(q.originalLimit * (1 + value / 100));
                    else if (type === 'add') q.newLimit = q.originalLimit + value;
                    else if (type === 'set') q.newLimit = value;
                });
                renderManageTable();
            }

            function resetLimits() {
                manageQuotasList.forEach(q => q.newLimit = q.originalLimit);
                renderManageTable();
            }

            function toggleSelectAllManage() {
                const checked = document.getElementById('selectAllManage').checked;
                document.querySelectorAll('.manage-check').forEach(c => c.checked = checked);
            }

            async function updateQuotas() {
                const { surveyId } = getApiParams();
                const toUpdate = manageQuotasList.filter((q, i) => {
                    const checkbox = document.querySelector(`.manage-check[data-index="${i}"]`);
                    return checkbox?.checked && q.newLimit !== q.originalLimit;
                });

                if (!toUpdate.length) return alert('Vui l√≤ng ch·ªçn quota ƒë√£ ch·ªânh s·ª≠a ƒë·ªÉ c·∫≠p nh·∫≠t');

                const btn = document.getElementById('updateBtn');
                btn.disabled = true; btn.innerHTML = '<span class="spinner"></span> ƒêang c·∫≠p nh·∫≠t...';

                let success = 0, errors = 0;

                for (const q of toUpdate) {
                    try {
                        // Use plural 'quotas' as singular 'quota' returned 404 in tests
                        const data = await alchemerAPI(`survey/${surveyId}/quotas/${q.id}`, 'POST', {}, { limit: q.newLimit });

                        if (data && data.result_ok) { q.originalLimit = q.newLimit; q.status = '‚úÖ ƒê√£ l∆∞u'; success++; }
                        else { q.status = '‚ùå L·ªói'; errors++; }
                    } catch (e) { q.status = '‚ùå L·ªói'; errors++; }
                    await new Promise(r => setTimeout(r, 300));
                }

                renderManageTable();
                document.getElementById('updateTotal').textContent = toUpdate.length;
                document.getElementById('updateSuccess').textContent = success;
                document.getElementById('updateError').textContent = errors;
                document.getElementById('updateResultsCard').classList.remove('hidden');
                btn.disabled = false; btn.innerHTML = 'üíæ C·∫≠p nh·∫≠t Limit';
            }



            // Delete from Manage Tab (using checkboxes in manage table)
            async function deleteSelectedFromManage() {
                const selected = Array.from(document.querySelectorAll('.manage-check:checked')).map(c => c.value);
                if (!selected.length) return alert('Ch·ªçn √≠t nh·∫•t 1 quota ƒë·ªÉ x√≥a');
                if (!confirm(`‚ö†Ô∏è X√≥a ${selected.length} quota?\n\nH√†nh ƒë·ªông n√†y KH√îNG TH·ªÇ ho√†n t√°c!`)) return;

                const { surveyId } = getApiParams();
                const btn = document.getElementById('deleteSelectedBtn');
                btn.disabled = true; btn.innerHTML = '<span class="spinner"></span> ƒêang x√≥a...';

                let lastError = null;
                for (const id of selected) {
                    try {
                        // Use plural 'quotas' and POST with _method=DELETE override
                        const data = await alchemerAPI(`survey/${surveyId}/quotas/${id}`, 'POST', { _method: 'DELETE' });
                        if (data && data.result_ok) {
                            // Remove from list and table
                            manageQuotasList = manageQuotasList.filter(q => q.id != id);
                            success++;
                        } else {
                            errors++;
                            lastError = data?.message || 'Kh√¥ng r√µ nguy√™n nh√¢n';
                        }
                    } catch (e) {
                        errors++;
                        lastError = e.message;
                    }
                    await new Promise(r => setTimeout(r, 300));
                }

                renderManageTable();
                document.getElementById('updateTotal').textContent = selected.length;
                document.getElementById('updateSuccess').textContent = success;
                document.getElementById('updateError').textContent = errors;
                document.getElementById('updateResultsCard').classList.remove('hidden');

                btn.disabled = false; btn.innerHTML = 'üóëÔ∏è X√≥a quota ƒë√£ ch·ªçn';

                if (success > 0) {
                    alert(`‚úÖ ƒê√£ x√≥a ${success} quota th√†nh c√¥ng!${errors > 0 ? `\n‚ö†Ô∏è ${errors} quota b·ªã l·ªói. L·ªói cu·ªëi: ${lastError}` : ''}`);
                } else {
                    alert(`‚ùå Kh√¥ng x√≥a ƒë∆∞·ª£c quota n√†o. ${errors} l·ªói.\nChi ti·∫øt l·ªói: ${lastError}\n\nüí° Vui l√≤ng nh·∫•n F12 (Console) ƒë·ªÉ xem chi ti·∫øt.`);
                }
            }

            function clearPlayground() {
                if (createQuotasList.length > 0) {
                    if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu ƒëang chu·∫©n b·ªã kh√¥ng?')) return;
                }

                createQuotasList = [];
                createDeletedHistory = [];

                const quotaData = document.getElementById('quotaData');
                if (quotaData) quotaData.value = '';

                const previewCard = document.getElementById('createPreviewCard');
                if (previewCard) previewCard.classList.add('hidden');

                const resultsCard = document.getElementById('createResultsCard');
                if (resultsCard) resultsCard.classList.add('hidden');

                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) undoBtn.classList.add('hidden');

                renderCreatePreview();
                alert('‚úÖ ƒê√£ x√≥a s·∫°ch d·ªØ li·ªáu chu·∫©n b·ªã!');
            }

            // ========== CROSS-TAB GENERATOR ==========
            let crosstabDimensions = []; // Array of { questionId, questionName, options: [{id, name}] }
            let dimensionCounter = 0;
            let customLogicGroups = []; // For custom logic mode
            let groupCounter = 0;

            function updateCrosstabMode() {
                const mode = document.querySelector('input[name="crosstabMode"]:checked').value;
                const cartesianSection = document.getElementById('cartesianModeSection');
                const customSection = document.getElementById('customModeSection');
                const cartesianSettings = document.getElementById('cartesianSettings');
                const cartesianButtons = document.getElementById('cartesianButtons');

                if (mode === 'cartesian') {
                    cartesianSection.classList.remove('hidden');
                    customSection.classList.add('hidden');
                    cartesianSettings.classList.remove('hidden');
                    cartesianButtons.classList.remove('hidden');
                } else {
                    cartesianSection.classList.add('hidden');
                    customSection.classList.remove('hidden');
                    cartesianSettings.classList.add('hidden');
                    cartesianButtons.classList.add('hidden');
                }
            }

            function addCrosstabDimension() {
                dimensionCounter++;
                const dimId = `dim-${dimensionCounter}`;

                const dimHtml = `
                <div id="${dimId}" class="crosstab-dimension" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 12px;">
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <span style="color: #ffc107; font-weight: bold;">üìå Dimension ${dimensionCounter}:</span>
                        <input type="text" id="${dimId}-qid" placeholder="Question ID (VD: 150)" style="width: 150px;" onchange="loadDimensionOptions('${dimId}')">
                        <button class="btn btn-sm btn-secondary" onclick="loadDimensionOptions('${dimId}')">üîç T·∫£i Options</button>
                        <button class="btn btn-sm btn-danger" onclick="removeCrosstabDimension('${dimId}')" style="margin-left: auto;">‚úï</button>
                    </div>
                    <div id="${dimId}-info" style="color: #8892b0; font-size: 0.9rem; margin-bottom: 8px;"></div>
                    <div id="${dimId}-options" style="display: flex; flex-wrap: wrap; gap: 6px;">
                        <span style="color: #666; font-style: italic;">Nh·∫≠p Question ID v√† nh·∫•n "T·∫£i Options"</span>
                    </div>
                </div>
            `;

                document.getElementById('crosstabDimensions').insertAdjacentHTML('beforeend', dimHtml);
            }

            function removeCrosstabDimension(dimId) {
                document.getElementById(dimId)?.remove();
                crosstabDimensions = crosstabDimensions.filter(d => d.dimId !== dimId);
                updateCrosstabPreview();
            }

            function clearCrosstabDimensions() {
                document.getElementById('crosstabDimensions').innerHTML = '';
                crosstabDimensions = [];
                dimensionCounter = 0;
                document.getElementById('crosstabPreview').classList.add('hidden');
            }

            async function loadDimensionOptions(dimId) {
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');

                const questionId = document.getElementById(`${dimId}-qid`).value.trim();
                if (!questionId) return alert('Vui l√≤ng nh·∫≠p Question ID');

                const infoEl = document.getElementById(`${dimId}-info`);
                const optionsEl = document.getElementById(`${dimId}-options`);

                infoEl.innerHTML = '<span style="color: #00d9ff;">‚è≥ ƒêang t·∫£i...</span>';
                optionsEl.innerHTML = '';

                try {
                    const data = await alchemerAPI(`survey/${surveyId}/question/${questionId}`);

                    if (!data || !data.result_ok) {
                        infoEl.innerHTML = `<span style="color: #ff5252;">‚ùå ${data?.message || 'Kh√¥ng t√¨m th·∫•y Question'}</span>`;
                        return;
                    }

                    const question = data.data;
                    const options = question.options || [];
                    const questionName = question.title?.English || question.shortname || `Question ${questionId}`;

                    if (options.length === 0) {
                        infoEl.innerHTML = `<span style="color: #ff5252;">‚ö†Ô∏è Question n√†y kh√¥ng c√≥ options</span>`;
                        return;
                    }

                    infoEl.innerHTML = `<span style="color: #00ff88;">‚úÖ ${escapeHtml(questionName)}</span> <span style="color: #8892b0;">(${options.length} options)</span>`;

                    optionsEl.innerHTML = `
                    <div style="width: 100%; margin-bottom: 8px;">
                        <label style="display: inline-flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="checkbox" onchange="toggleAllDimensionOptions('${dimId}', this.checked)">
                            <span style="font-size: 0.85rem; color: #00d9ff;">Ch·ªçn t·∫•t c·∫£</span>
                        </label>
                    </div>
                    ${options.map(opt => {
                        const optName = opt.title?.English || opt.value || opt.id;
                        const optionId = `${questionId}-${opt.id}`;
                        return `
                            <label class="crosstab-option" style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: rgba(0,217,255,0.1); border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                <input type="checkbox" class="${dimId}-opt" data-optid="${optionId}" data-optname="${escapeHtml(optName)}" onchange="updateDimensionData('${dimId}')">
                                <span>${escapeHtml(optName)}</span>
                            </label>
                        `;
                    }).join('')}
                `;

                    const existingDim = crosstabDimensions.find(d => d.dimId === dimId);
                    if (existingDim) {
                        existingDim.questionId = questionId;
                        existingDim.questionName = questionName;
                        existingDim.options = [];
                    } else {
                        crosstabDimensions.push({
                            dimId,
                            questionId,
                            questionName,
                            options: []
                        });
                    }

                } catch (e) {
                    infoEl.innerHTML = `<span style="color: #ff5252;">‚ùå L·ªói: ${e.message}</span>`;
                    console.error('Load dimension error:', e);
                }
            }

            function toggleAllDimensionOptions(dimId, checked) {
                document.querySelectorAll(`.${dimId}-opt`).forEach(cb => {
                    cb.checked = checked;
                });
                updateDimensionData(dimId);
            }

            function updateDimensionData(dimId) {
                const dim = crosstabDimensions.find(d => d.dimId === dimId);
                if (!dim) return;

                dim.options = [];
                document.querySelectorAll(`.${dimId}-opt:checked`).forEach(cb => {
                    dim.options.push({
                        id: cb.dataset.optid,
                        name: cb.dataset.optname
                    });
                });

                updateCrosstabPreview();
            }

            function updateCrosstabPreview() {
                const combinations = generateCrosstabCombinations();
                const previewEl = document.getElementById('crosstabPreview');
                const listEl = document.getElementById('crosstabPreviewList');
                const countEl = document.getElementById('crosstabCount');

                if (combinations.length === 0) {
                    previewEl.classList.add('hidden');
                    return;
                }

                previewEl.classList.remove('hidden');
                countEl.textContent = `${combinations.length} quota s·∫Ω ƒë∆∞·ª£c t·∫°o`;

                const preview = combinations.slice(0, 20);
                const dimOperator = document.getElementById('cartesianDimOperator')?.value || 'and';
                listEl.innerHTML = preview.map((combo, i) => `
                <div style="padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px; margin-bottom: 4px; font-size: 0.85rem;">
                    <span style="color: #8892b0;">#${i + 1}</span>
                    <span style="color: #fff; margin-left: 8px;">${escapeHtml(combo.name)}</span>
                    <span style="color: #ffc107; margin-left: 8px; font-size: 0.75rem;">(${combo.rules.length} ƒëi·ªÅu ki·ªán, ${dimOperator.toUpperCase()})</span>
                </div>
            `).join('') + (combinations.length > 20 ? `<div style="padding: 6px; color: #ffc107; text-align: center;">... v√† ${combinations.length - 20} quota kh√°c</div>` : '');
            }

            function generateCrosstabCombinations() {
                const validDimensions = crosstabDimensions.filter(d => d.options.length > 0);

                if (validDimensions.length === 0) return [];

                function cartesian(arrays) {
                    if (arrays.length === 0) return [[]];
                    if (arrays.length === 1) return arrays[0].map(item => [item]);

                    const [first, ...rest] = arrays;
                    const restProduct = cartesian(rest);

                    return first.flatMap(item =>
                        restProduct.map(restItems => [item, ...restItems])
                    );
                }

                const optionSets = validDimensions.map(d =>
                    d.options.map(opt => ({
                        questionId: d.questionId,
                        questionName: d.questionName,
                        optionId: opt.id,
                        optionName: opt.name
                    }))
                );

                const combinations = cartesian(optionSets);
                const dimOperator = document.getElementById('cartesianDimOperator')?.value || 'and';

                return combinations.map(combo => {
                    const name = combo.map(c => c.optionName).join(' + ');
                    // Build rules with next_operator for API
                    const rules = combo.map((c, idx) => ({
                        input_value: c.questionId,
                        operator: '12', // is one of the following answers
                        answers_type: '17', // Question Option
                        answers_values: [c.optionId],
                        next_operator: idx < combo.length - 1 ? dimOperator : '' // Last rule has empty next_operator
                    }));

                    return { name, rules, combo };
                });
            }

            function previewCrosstabQuotas() {
                const validDimensions = crosstabDimensions.filter(d => d.options.length > 0);

                if (validDimensions.length === 0) {
                    return alert('Vui l√≤ng th√™m √≠t nh·∫•t 1 dimension v√† ch·ªçn options');
                }

                updateCrosstabPreview();
                const dimOperator = document.getElementById('cartesianDimOperator')?.value || 'and';
                const combinations = generateCrosstabCombinations();
                alert(`üìä S·∫Ω t·∫°o ${combinations.length} quota t·ª´ ${validDimensions.length} dimensions:\n\nƒêi·ªÅu ki·ªán: ${dimOperator.toUpperCase()}\n\n${validDimensions.map(d => `- ${d.questionName}: ${d.options.length} options`).join('\n')}`);
            }

            function generateCrosstabQuotas() {
                const combinations = generateCrosstabCombinations();

                if (combinations.length === 0) {
                    return alert('Vui l√≤ng th√™m dimensions v√† ch·ªçn options tr∆∞·ªõc');
                }

                if (combinations.length > 500) {
                    if (!confirm(`‚ö†Ô∏è S·∫Ω t·∫°o ${combinations.length} quota. S·ªë l∆∞·ª£ng l·ªõn c√≥ th·ªÉ m·∫•t th·ªùi gian. Ti·∫øp t·ª•c?`)) {
                        return;
                    }
                }

                const defaultLimit = parseInt(document.getElementById('crosstabDefaultLimit').value) || 50;
                const groupName = document.getElementById('crosstabGroupName').value || 'cross-tab';

                const newQuotas = combinations.map((combo, i) => ({
                    name: combo.name,
                    limit: defaultLimit,
                    group: groupName,
                    status: 'pending',
                    logic: {
                        templateName: `Cross-tab: ${combo.name}`,
                        answerType: '17',
                        operator: '12',
                        isMultiRule: true,
                        rules: combo.rules
                    },
                    originalIndex: createQuotasList.length + i
                }));

                createQuotasList = [...createQuotasList, ...newQuotas];
                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');

                alert(`‚úÖ ƒê√£ th√™m ${newQuotas.length} cross-tab quota v√†o danh s√°ch!\n\nChuy·ªÉn ƒë·∫øn ph·∫ßn "Xem tr∆∞·ªõc" ƒë·ªÉ ki·ªÉm tra v√† t·∫°o quota.`);
            }

            // ========== CUSTOM LOGIC MODE ==========
            function addCustomLogicGroup() {
                groupCounter++;
                const groupId = `group-${groupCounter}`;

                const prevGroupEl = document.querySelector('#customLogicGroups > .custom-logic-group:last-child');

                // Add operator selector before new group (except for first group)
                let operatorHtml = '';
                if (prevGroupEl) {
                    operatorHtml = `
                    <div class="group-operator-row" style="display: flex; align-items: center; justify-content: center; gap: 10px; padding: 8px;">
                        <span style="color: #8892b0;">ƒêi·ªÅu ki·ªán gi·ªØa Groups:</span>
                        <select class="group-next-operator" style="width: 80px;">
                            <option value="and" selected>AND</option>
                            <option value="or">OR</option>
                        </select>
                    </div>
                `;
                }

                const groupHtml = `
                ${operatorHtml}
                <div id="${groupId}" class="custom-logic-group" style="background: rgba(255,193,7,0.05); border: 2px solid rgba(255,193,7,0.3); border-radius: 8px; padding: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <span style="color: #ffc107; font-weight: bold; font-size: 1.1rem;">üìÅ Group ${groupCounter}</span>
                        <button class="btn btn-sm btn-danger" onclick="removeCustomLogicGroup('${groupId}')">‚úï X√≥a Group</button>
                    </div>
                    
                    <!-- Rules container -->
                    <div id="${groupId}-rules" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px;">
                        <!-- Rules will be added here -->
                    </div>
                    
                    <button class="btn btn-sm btn-secondary" onclick="addRuleToGroup('${groupId}')">‚ûï Th√™m ƒëi·ªÅu ki·ªán</button>
                </div>
            `;

                document.getElementById('customLogicGroups').insertAdjacentHTML('beforeend', groupHtml);

                // Add first rule automatically
                addRuleToGroup(groupId);
            }

            function removeCustomLogicGroup(groupId) {
                const groupEl = document.getElementById(groupId);
                const prevOperator = groupEl?.previousElementSibling;

                // Remove operator row before this group
                if (prevOperator?.classList.contains('group-operator-row')) {
                    prevOperator.remove();
                }

                groupEl?.remove();
            }

            function clearCustomLogicGroups() {
                document.getElementById('customLogicGroups').innerHTML = '';
                groupCounter = 0;
            }

            let ruleCounter = 0;
            let cachedQuestionsForCustom = []; // Cached questions for dropdowns

            async function loadQuestionsForCustomLogic() {
                const { surveyId } = getApiParams();
                if (!surveyId) return alert('Vui l√≤ng nh·∫≠p Survey ID');

                const statusEl = document.getElementById('customQuestionsStatus');
                statusEl.innerHTML = '‚è≥ ƒêang t·∫£i...';

                try {
                    const data = await alchemerAPI(`survey/${surveyId}/question`);
                    if (data && data.result_ok) {
                        const questions = data.data || [];
                        // Filter questions that have options (Radio, Checkbox, etc.)
                        cachedQuestionsForCustom = questions.filter(q =>
                            q.options && q.options.length > 0
                        ).map(q => ({
                            id: q.id,
                            title: q.title?.English || q.shortname || `Question ${q.id}`,
                            type: q._type || q.type,
                            options: q.options.map(opt => ({
                                id: `${q.id}-${opt.id}`,
                                title: opt.title?.English || opt.value || opt.id
                            }))
                        }));

                        statusEl.innerHTML = `‚úÖ ƒê√£ t·∫£i ${cachedQuestionsForCustom.length} questions c√≥ options`;

                        // Update all existing question dropdowns
                        updateAllQuestionDropdowns();
                    } else {
                        statusEl.innerHTML = `‚ùå ${data?.message || 'L·ªói'}`;
                    }
                } catch (e) {
                    statusEl.innerHTML = `‚ùå ${e.message}`;
                }
            }

            function getQuestionOptionsHtml() {
                if (cachedQuestionsForCustom.length === 0) {
                    return '<option value="">-- T·∫£i Questions tr∆∞·ªõc --</option>';
                }
                return '<option value="">-- Ch·ªçn Question --</option>' +
                    cachedQuestionsForCustom.map(q =>
                        `<option value="${q.id}" data-options='${JSON.stringify(q.options)}'>${escapeHtml(q.title)} (ID: ${q.id})</option>`
                    ).join('');
            }

            function updateAllQuestionDropdowns() {
                document.querySelectorAll('.rule-question-select').forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = getQuestionOptionsHtml();
                    if (currentValue) select.value = currentValue;
                });
            }

            function addRuleToGroup(groupId) {
                ruleCounter++;
                const ruleId = `rule-${ruleCounter}`;
                const rulesContainer = document.getElementById(`${groupId}-rules`);
                const existingRules = rulesContainer.querySelectorAll('.custom-rule');

                // Add operator selector before new rule (except for first rule in group)
                let operatorHtml = '';
                if (existingRules.length > 0) {
                    operatorHtml = `
                    <div class="rule-operator-row" style="display: flex; align-items: center; gap: 10px; padding: 4px 0 4px 20px;">
                        <select class="rule-next-operator" style="width: 80px;">
                            <option value="and" selected>AND</option>
                            <option value="or">OR</option>
                        </select>
                    </div>
                `;
                }

                const ruleHtml = `
                ${operatorHtml}
                <div id="${ruleId}" class="custom-rule" style="background: rgba(255,255,255,0.03); padding: 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-start;">
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <select class="rule-type" style="width: 140px;" onchange="onRuleTypeChange('${ruleId}')">
                                <option value="question">Question Option</option>
                                <option value="hidden">Hidden Value</option>
                            </select>
                        </div>
                        
                        <!-- Question Mode -->
                        <div class="rule-question-mode" style="display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-start;">
                            <select class="rule-question-select" style="width: 200px;" onchange="onQuestionSelect('${ruleId}')">
                                ${getQuestionOptionsHtml()}
                            </select>
                            <select class="rule-operator" style="width: 140px;">
                                <option value="12">is one of</option>
                                <option value="4">is exactly equal</option>
                                <option value="5">is not equal</option>
                                <option value="20">is answered</option>
                                <option value="21">is not answered</option>
                            </select>
                            <div class="rule-options-container" style="display: flex; flex-wrap: wrap; gap: 4px; max-width: 300px;">
                                <span style="color: #666; font-size: 0.85rem;">Ch·ªçn Question tr∆∞·ªõc...</span>
                            </div>
                        </div>
                        
                        <!-- Hidden Value Mode (hidden by default) -->
                        <div class="rule-hidden-mode hidden" style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                            <input type="text" class="rule-hidden-id" placeholder="Hidden Value ID" style="width: 120px;">
                            <select class="rule-operator-hidden" style="width: 140px;">
                                <option value="4">is exactly equal</option>
                                <option value="5">is not equal</option>
                                <option value="20">is answered</option>
                                <option value="21">is not answered</option>
                                <option value="14">contains</option>
                            </select>
                            <input type="text" class="rule-hidden-value" placeholder="Gi√° tr·ªã" style="width: 150px;">
                        </div>
                        
                        <button class="btn btn-sm btn-danger" onclick="removeRuleFromGroup('${ruleId}')" style="padding: 4px 8px; align-self: flex-start;">‚úï</button>
                    </div>
                </div>
            `;

                rulesContainer.insertAdjacentHTML('beforeend', ruleHtml);
            }

            function onRuleTypeChange(ruleId) {
                const ruleEl = document.getElementById(ruleId);
                const typeSelect = ruleEl.querySelector('.rule-type');
                const questionMode = ruleEl.querySelector('.rule-question-mode');
                const hiddenMode = ruleEl.querySelector('.rule-hidden-mode');

                if (typeSelect.value === 'question') {
                    questionMode.classList.remove('hidden');
                    questionMode.style.display = 'flex';
                    hiddenMode.classList.add('hidden');
                    hiddenMode.style.display = 'none';
                } else {
                    questionMode.classList.add('hidden');
                    questionMode.style.display = 'none';
                    hiddenMode.classList.remove('hidden');
                    hiddenMode.style.display = 'flex';
                }
            }

            function onQuestionSelect(ruleId) {
                const ruleEl = document.getElementById(ruleId);
                const questionSelect = ruleEl.querySelector('.rule-question-select');
                const optionsContainer = ruleEl.querySelector('.rule-options-container');
                const selectedOption = questionSelect.options[questionSelect.selectedIndex];

                if (!questionSelect.value) {
                    optionsContainer.innerHTML = '<span style="color: #666; font-size: 0.85rem;">Ch·ªçn Question tr∆∞·ªõc...</span>';
                    return;
                }

                try {
                    const options = JSON.parse(selectedOption.dataset.options || '[]');
                    if (options.length === 0) {
                        optionsContainer.innerHTML = '<span style="color: #ff5252;">Kh√¥ng c√≥ options</span>';
                        return;
                    }

                    // Render checkboxes for options
                    optionsContainer.innerHTML = `
                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                        ${options.map(opt => `
                            <label style="display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; background: rgba(0,217,255,0.1); border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                <input type="checkbox" class="rule-option-checkbox" value="${opt.id}">
                                <span>${escapeHtml(opt.title)}</span>
                            </label>
                        `).join('')}
                    </div>
                `;
                } catch (e) {
                    optionsContainer.innerHTML = '<span style="color: #ff5252;">L·ªói parse options</span>';
                }
            }

            function removeRuleFromGroup(ruleId) {
                const ruleEl = document.getElementById(ruleId);
                const prevOperator = ruleEl?.previousElementSibling;

                if (prevOperator?.classList.contains('rule-operator-row')) {
                    prevOperator.remove();
                }

                ruleEl?.remove();
            }

            function updateRuleInputs(ruleId) {
                const ruleEl = document.getElementById(ruleId);
                const typeSelect = ruleEl.querySelector('.rule-type');
                const inputValueEl = ruleEl.querySelector('.rule-input-value');
                const answersValuesEl = ruleEl.querySelector('.rule-answers-values');

                if (typeSelect.value === 'question') {
                    inputValueEl.placeholder = 'Question ID';
                    answersValuesEl.placeholder = 'Option ID (VD: 150-10001)';
                } else {
                    inputValueEl.placeholder = 'Hidden Value ID';
                    answersValuesEl.placeholder = 'Gi√° tr·ªã (VD: panel)';
                }
            }

            function buildCustomLogicGroups() {
                const groupsContainer = document.getElementById('customLogicGroups');
                const groupElements = groupsContainer.querySelectorAll('.custom-logic-group');
                const groups = [];

                groupElements.forEach((groupEl, groupIdx) => {
                    const rulesContainer = groupEl.querySelector('[id$="-rules"]');
                    const ruleElements = rulesContainer.querySelectorAll('.custom-rule');
                    const rules = [];

                    ruleElements.forEach((ruleEl, ruleIdx) => {
                        const type = ruleEl.querySelector('.rule-type').value;

                        let inputValue, operator, answersValues;

                        if (type === 'question') {
                            // Question mode - read from dropdowns and checkboxes
                            const questionSelect = ruleEl.querySelector('.rule-question-select');
                            inputValue = questionSelect?.value || '';
                            operator = ruleEl.querySelector('.rule-operator')?.value || '12';

                            // Get selected options from checkboxes
                            const selectedOptions = [];
                            ruleEl.querySelectorAll('.rule-option-checkbox:checked').forEach(cb => {
                                selectedOptions.push(cb.value);
                            });
                            answersValues = selectedOptions;
                        } else {
                            // Hidden Value mode
                            inputValue = ruleEl.querySelector('.rule-hidden-id')?.value?.trim() || '';
                            operator = ruleEl.querySelector('.rule-operator-hidden')?.value || '4';
                            answersValues = ruleEl.querySelector('.rule-hidden-value')?.value?.trim() || '';
                        }

                        if (!inputValue) return;
                        if (type === 'question' && (!answersValues || answersValues.length === 0)) return;

                        // Get next_operator from the next operator row
                        const nextOperatorRow = ruleEl.nextElementSibling;
                        let nextOperator = '';
                        if (nextOperatorRow?.classList.contains('rule-operator-row')) {
                            nextOperator = nextOperatorRow.querySelector('.rule-next-operator')?.value || '';
                        }

                        rules.push({
                            input_value: inputValue,
                            operator: operator,
                            answers_type: type === 'question' ? '17' : '2',
                            answers_values: answersValues,
                            next_operator: nextOperator
                        });
                    });

                    if (rules.length === 0) return;

                    // Get group next_operator from the operator row before next group
                    const nextGroupOperatorRow = groupEl.nextElementSibling;
                    let groupNextOperator = '';
                    if (nextGroupOperatorRow?.classList.contains('group-operator-row')) {
                        groupNextOperator = nextGroupOperatorRow.querySelector('.group-next-operator')?.value || '';
                    }

                    groups.push({
                        rules: rules,
                        next_operator: groupNextOperator
                    });
                });

                return groups;
            }

            // ========== COPY/PASTE/CLONE FUNCTIONS ==========
            let copiedGroupsStructure = null;

            function copyGroupsStructure() {
                const groups = buildCustomLogicGroups();
                if (groups.length === 0) {
                    return alert('Kh√¥ng c√≥ groups n√†o ƒë·ªÉ copy');
                }

                copiedGroupsStructure = JSON.parse(JSON.stringify(groups)); // Deep clone
                localStorage.setItem('copied_groups_structure', JSON.stringify(copiedGroupsStructure));
                alert(`‚úÖ ƒê√£ copy ${groups.length} group(s) v·ªõi ${groups.reduce((sum, g) => sum + g.rules.length, 0)} ƒëi·ªÅu ki·ªán`);
            }

            function pasteGroupsStructure() {
                let groups = copiedGroupsStructure;
                if (!groups) {
                    // Try to load from localStorage
                    const saved = localStorage.getItem('copied_groups_structure');
                    if (saved) {
                        groups = JSON.parse(saved);
                    }
                }

                if (!groups || groups.length === 0) {
                    return alert('Kh√¥ng c√≥ c·∫•u tr√∫c n√†o ƒë·ªÉ paste. H√£y Copy tr∆∞·ªõc!');
                }

                // Clear current groups and rebuild from structure
                clearCustomLogicGroups();

                // Need to load questions first if not loaded
                if (cachedQuestionsForCustom.length === 0) {
                    alert('‚ö†Ô∏è Vui l√≤ng "T·∫£i Questions t·ª´ API" tr∆∞·ªõc ƒë·ªÉ c√≥ th·ªÉ hi·ªÉn th·ªã ƒë√∫ng options');
                }

                // Rebuild groups from structure
                groups.forEach((group, gIdx) => {
                    addCustomLogicGroup();
                    const groupId = `group-${groupCounter}`;
                    const rulesContainer = document.getElementById(`${groupId}-rules`);

                    // Remove the auto-added first rule
                    rulesContainer.innerHTML = '';

                    group.rules.forEach((rule, rIdx) => {
                        // Add operator row if not first rule
                        if (rIdx > 0 && rIdx < group.rules.length) {
                            const prevRule = group.rules[rIdx - 1];
                            if (prevRule.next_operator) {
                                rulesContainer.insertAdjacentHTML('beforeend', `
                                <div class="rule-operator-row" style="display: flex; align-items: center; gap: 10px; padding: 4px 0 4px 20px;">
                                    <select class="rule-next-operator" style="width: 80px;">
                                        <option value="and" ${prevRule.next_operator === 'and' ? 'selected' : ''}>AND</option>
                                        <option value="or" ${prevRule.next_operator === 'or' ? 'selected' : ''}>OR</option>
                                    </select>
                                </div>
                            `);
                            }
                        }

                        // Add rule
                        addRuleToGroupWithData(groupId, rule);
                    });

                    // Set group next operator
                    if (gIdx < groups.length - 1 && group.next_operator) {
                        const groupEl = document.getElementById(groupId);
                        const nextOpRow = groupEl?.nextElementSibling;
                        if (nextOpRow?.classList.contains('group-operator-row')) {
                            const select = nextOpRow.querySelector('.group-next-operator');
                            if (select) select.value = group.next_operator;
                        }
                    }
                });

                alert(`‚úÖ ƒê√£ paste ${groups.length} group(s)`);
            }

            function addRuleToGroupWithData(groupId, ruleData) {
                ruleCounter++;
                const ruleId = `rule-${ruleCounter}`;
                const rulesContainer = document.getElementById(`${groupId}-rules`);

                const isQuestion = ruleData.answers_type === '17';

                const ruleHtml = `
                <div id="${ruleId}" class="custom-rule" style="background: rgba(255,255,255,0.03); padding: 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-start;">
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <select class="rule-type" style="width: 140px;" onchange="onRuleTypeChange('${ruleId}')">
                                <option value="question" ${isQuestion ? 'selected' : ''}>Question Option</option>
                                <option value="hidden" ${!isQuestion ? 'selected' : ''}>Hidden Value</option>
                            </select>
                        </div>
                        
                        <!-- Question Mode -->
                        <div class="rule-question-mode" style="display: ${isQuestion ? 'flex' : 'none'}; gap: 8px; flex-wrap: wrap; align-items: flex-start;">
                            <select class="rule-question-select" style="width: 200px;" onchange="onQuestionSelect('${ruleId}')">
                                ${getQuestionOptionsHtml()}
                            </select>
                            <select class="rule-operator" style="width: 140px;">
                                <option value="12" ${ruleData.operator === '12' ? 'selected' : ''}>is one of</option>
                                <option value="4" ${ruleData.operator === '4' ? 'selected' : ''}>is exactly equal</option>
                                <option value="5" ${ruleData.operator === '5' ? 'selected' : ''}>is not equal</option>
                                <option value="20" ${ruleData.operator === '20' ? 'selected' : ''}>is answered</option>
                                <option value="21" ${ruleData.operator === '21' ? 'selected' : ''}>is not answered</option>
                            </select>
                            <div class="rule-options-container" style="display: flex; flex-wrap: wrap; gap: 4px; max-width: 300px;">
                                <span style="color: #ffc107; font-size: 0.85rem;">üìã Q${ruleData.input_value}: ${Array.isArray(ruleData.answers_values) ? ruleData.answers_values.join(', ') : ruleData.answers_values}</span>
                            </div>
                        </div>
                        
                        <!-- Hidden Value Mode -->
                        <div class="rule-hidden-mode ${isQuestion ? 'hidden' : ''}" style="display: ${!isQuestion ? 'flex' : 'none'}; gap: 8px; flex-wrap: wrap; align-items: center;">
                            <input type="text" class="rule-hidden-id" placeholder="Hidden Value ID" style="width: 120px;" value="${!isQuestion ? ruleData.input_value : ''}">
                            <select class="rule-operator-hidden" style="width: 140px;">
                                <option value="4" ${ruleData.operator === '4' ? 'selected' : ''}>is exactly equal</option>
                                <option value="5" ${ruleData.operator === '5' ? 'selected' : ''}>is not equal</option>
                                <option value="20" ${ruleData.operator === '20' ? 'selected' : ''}>is answered</option>
                                <option value="21" ${ruleData.operator === '21' ? 'selected' : ''}>is not answered</option>
                                <option value="14" ${ruleData.operator === '14' ? 'selected' : ''}>contains</option>
                            </select>
                            <input type="text" class="rule-hidden-value" placeholder="Gi√° tr·ªã" style="width: 150px;" value="${!isQuestion ? ruleData.answers_values : ''}">
                        </div>
                        
                        <button class="btn btn-sm btn-danger" onclick="removeRuleFromGroup('${ruleId}')" style="padding: 4px 8px; align-self: flex-start;">‚úï</button>
                    </div>
                </div>
            `;

                rulesContainer.insertAdjacentHTML('beforeend', ruleHtml);

                // Set question select value if question mode
                if (isQuestion) {
                    const ruleEl = document.getElementById(ruleId);
                    const questionSelect = ruleEl.querySelector('.rule-question-select');
                    if (questionSelect && ruleData.input_value) {
                        questionSelect.value = ruleData.input_value;
                        // Trigger option load and pre-select
                        setTimeout(() => {
                            onQuestionSelect(ruleId);
                            // Pre-check the options
                            setTimeout(() => {
                                const values = Array.isArray(ruleData.answers_values) ? ruleData.answers_values : [ruleData.answers_values];
                                values.forEach(val => {
                                    const cb = ruleEl.querySelector(`.rule-option-checkbox[value="${val}"]`);
                                    if (cb) cb.checked = true;
                                });
                            }, 100);
                        }, 50);
                    }
                }
            }

            function cloneCurrentQuota() {
                const groups = buildCustomLogicGroups();
                if (groups.length === 0) {
                    return alert('Kh√¥ng c√≥ logic n√†o ƒë·ªÉ clone');
                }

                const count = parseInt(prompt('Nh·∫≠p s·ªë l∆∞·ª£ng quota mu·ªën t·∫°o th√™m:', '5'));
                if (!count || count < 1) return;

                const baseNames = prompt('Nh·∫≠p danh s√°ch t√™n quota (m·ªói d√≤ng 1 t√™n):\n\nVD:\n20-29 + Nam\n30-39 + Nam\n40-49 + Nam', '');
                if (!baseNames) return;

                const names = baseNames.split('\n').filter(n => n.trim());
                const limit = parseInt(document.getElementById('customQuotaLimit').value) || 50;

                names.forEach(name => {
                    const newQuota = {
                        name: name.trim(),
                        limit: limit,
                        group: 'custom-logic',
                        status: 'pending',
                        logic: {
                            templateName: `Custom: ${name.trim()}`,
                            isCustomGroups: true,
                            groups: JSON.parse(JSON.stringify(groups)) // Deep clone
                        },
                        originalIndex: createQuotasList.length
                    };
                    createQuotasList.push(newQuota);
                });

                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');
                alert(`‚úÖ ƒê√£ th√™m ${names.length} quota v·ªõi c√πng c·∫•u tr√∫c logic!`);
            }

            function addMultipleCustomQuotas() {
                const groups = buildCustomLogicGroups();
                if (groups.length === 0) {
                    return alert('Vui l√≤ng thi·∫øt l·∫≠p logic tr∆∞·ªõc');
                }

                const namesInput = prompt('Nh·∫≠p danh s√°ch t√™n quota (m·ªói d√≤ng 1 t√™n):\n\nVD:\nHN + Nam + 20-29\nHN + Nam + 30-39\nHCM + N·ªØ + 20-29');
                if (!namesInput) return;

                const names = namesInput.split('\n').filter(n => n.trim());
                const limit = parseInt(document.getElementById('customQuotaLimit').value) || 50;

                names.forEach(name => {
                    const newQuota = {
                        name: name.trim(),
                        limit: limit,
                        group: 'custom-logic',
                        status: 'pending',
                        logic: {
                            templateName: `Custom: ${name.trim()}`,
                            isCustomGroups: true,
                            groups: JSON.parse(JSON.stringify(groups))
                        },
                        originalIndex: createQuotasList.length
                    };
                    createQuotasList.push(newQuota);
                });

                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');
                alert(`‚úÖ ƒê√£ th√™m ${names.length} quota!`);
            }

            function addCustomQuotaToPreview() {
                const quotaName = document.getElementById('customQuotaName').value.trim();
                const quotaLimit = parseInt(document.getElementById('customQuotaLimit').value) || 50;

                if (!quotaName) {
                    return alert('Vui l√≤ng nh·∫≠p t√™n quota');
                }

                const groups = buildCustomLogicGroups();

                if (groups.length === 0) {
                    return alert('Vui l√≤ng th√™m √≠t nh·∫•t 1 group v·ªõi ƒëi·ªÅu ki·ªán');
                }

                // Create quota with custom groups
                const newQuota = {
                    name: quotaName,
                    limit: quotaLimit,
                    group: 'custom-logic',
                    status: 'pending',
                    logic: {
                        templateName: `Custom: ${quotaName}`,
                        isCustomGroups: true,
                        groups: groups
                    },
                    originalIndex: createQuotasList.length
                };

                createQuotasList.push(newQuota);
                renderCreatePreview();
                document.getElementById('createPreviewCard').classList.remove('hidden');

                alert(`‚úÖ ƒê√£ th√™m quota "${quotaName}" v√†o danh s√°ch!`);

                // Clear form
                document.getElementById('customQuotaName').value = '';
            }

            // ========== MULTILINE INPUT MODAL ==========
            let multilineCallback = null;

            function showMultilineModal(title, placeholder, callback) {
                multilineCallback = callback;
                document.getElementById('multilineModalTitle').textContent = title;
                document.getElementById('multilineModalTextarea').value = '';
                document.getElementById('multilineModalTextarea').placeholder = placeholder;
                document.getElementById('multilineModal').classList.remove('hidden');
                document.getElementById('multilineModalTextarea').focus();
            }

            function hideMultilineModal() {
                document.getElementById('multilineModal').classList.add('hidden');
                multilineCallback = null;
            }

            function submitMultilineModal() {
                const text = document.getElementById('multilineModalTextarea').value;
                if (multilineCallback) {
                    multilineCallback(text);
                }
                hideMultilineModal();
            }

            // ========== VIEW/EDIT LOGIC DETAIL ==========
            let currentEditingQuotaIndex = null;
            let editingRules = []; // Temporary storage for edited rules

            function viewLogicDetail(index) {
                const quota = createQuotasList[index];
                if (!quota) return alert('Kh√¥ng t√¨m th·∫•y quota');

                currentEditingQuotaIndex = index;

                // Check if questions are loaded
                if (cachedQuestionsForCustom.length === 0) {
                    const loadFirst = confirm('C·∫ßn t·∫£i danh s√°ch Questions tr∆∞·ªõc ƒë·ªÉ s·ª≠a logic.\n\nB·∫•m OK ƒë·ªÉ t·∫£i ngay.');
                    if (loadFirst) {
                        loadQuestionsForCustomLogic().then(() => {
                            viewLogicDetail(index); // Retry after loading
                        });
                    }
                    return;
                }

                // Extract rules from quota logic
                editingRules = [];
                let rulesOperator = 'and';

                if (quota.logic) {
                    if (quota.logic.isCustomGroups && quota.logic.groups && quota.logic.groups.length > 0) {
                        // Get rules from first group for simplicity
                        editingRules = JSON.parse(JSON.stringify(quota.logic.groups[0].rules || []));
                    } else if (quota.logic.isMultiRule && quota.logic.rules) {
                        editingRules = JSON.parse(JSON.stringify(quota.logic.rules));
                    } else if (quota.logic.key) {
                        // Single rule - convert to array format
                        editingRules = [{
                            input_value: quota.logic.key,
                            operator: quota.logic.operator || '12',
                            answers_type: quota.logic.answerType || '17',
                            answers_values: Array.isArray(quota.logic.value) ? quota.logic.value : [quota.logic.value],
                            next_operator: ''
                        }];
                    }
                }

                renderLogicEditor();
                document.getElementById('logicDetailTitle').textContent = `‚úèÔ∏è S·ª≠a Logic: ${quota.name}`;
                document.getElementById('logicDetailModal').classList.remove('hidden');
            }

            function renderLogicEditor() {
                const quota = createQuotasList[currentEditingQuotaIndex];

                let html = `
                <!-- Editable Name and Limit -->
                <div style="margin-bottom: 16px; display: grid; grid-template-columns: 1fr 120px; gap: 12px;">
                    <div>
                        <label style="font-size: 0.85rem; color: #8892b0;">T√™n Quota</label>
                        <input type="text" id="editQuotaName" value="${escapeHtml(quota?.name || '')}" 
                            style="width: 100%; padding: 10px 12px; font-size: 1rem; font-weight: 500;">
                    </div>
                    <div>
                        <label style="font-size: 0.85rem; color: #8892b0;">Limit</label>
                        <input type="number" id="editQuotaLimit" value="${quota?.limit || 50}" min="1"
                            style="width: 100%; padding: 10px 12px; font-size: 1rem;">
                    </div>
                </div>

                <div style="margin-bottom: 16px; background: rgba(0,217,255,0.1); padding: 12px; border-radius: 8px;">
                    <p style="color: #00d9ff; margin-bottom: 8px;">üìå S·ª≠a ƒëi·ªÅu ki·ªán logic cho quota n√†y</p>
                    <p style="font-size: 0.85rem; color: #8892b0;">Ch·ªçn Question t·ª´ dropdown, sau ƒë√≥ tick c√°c Options mu·ªën √°p d·ª•ng.</p>
                </div>
                
                <div id="editingRulesContainer" style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px;">
            `;

                editingRules.forEach((rule, idx) => {
                    html += renderEditableRule(rule, idx);
                });

                html += `</div>`;

                html += `
                <div style="display: flex; gap: 10px; margin-bottom: 16px;">
                    <button class="btn btn-sm btn-secondary" onclick="addEditingRule()">‚ûï Th√™m ƒëi·ªÅu ki·ªán</button>
                </div>
            `;

                document.getElementById('logicDetailContent').innerHTML = html;

                // Initialize option displays for existing rules
                editingRules.forEach((rule, idx) => {
                    if (rule.input_value) {
                        loadOptionsForEditRule(idx, rule.input_value, rule.answers_values);
                    }
                });
            }

            function renderEditableRule(rule, idx) {
                const prevOperator = idx > 0 ? (editingRules[idx - 1]?.next_operator || 'and') : '';

                let operatorRow = '';
                if (idx > 0) {
                    operatorRow = `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 4px 0 4px 20px;">
                        <select onchange="updateEditRuleOperator(${idx - 1}, this.value)" style="width: 80px;">
                            <option value="and" ${prevOperator === 'and' ? 'selected' : ''}>AND</option>
                            <option value="or" ${prevOperator === 'or' ? 'selected' : ''}>OR</option>
                        </select>
                    </div>
                `;
                }

                return `
                ${operatorRow}
                <div id="edit-rule-${idx}" style="background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-start; margin-bottom: 8px;">
                        <select class="edit-question-select" style="width: 220px;" onchange="onEditQuestionChange(${idx}, this.value)">
                            <option value="">-- Ch·ªçn Question --</option>
                            ${cachedQuestionsForCustom.map(q =>
                    `<option value="${q.id}" ${rule.input_value == q.id ? 'selected' : ''}>${escapeHtml(q.title)} (ID: ${q.id})</option>`
                ).join('')}
                        </select>
                        <select class="edit-operator-select" style="width: 130px;" onchange="updateEditRuleData(${idx}, 'operator', this.value)">
                            <option value="12" ${rule.operator === '12' ? 'selected' : ''}>is one of</option>
                            <option value="4" ${rule.operator === '4' ? 'selected' : ''}>equals</option>
                            <option value="5" ${rule.operator === '5' ? 'selected' : ''}>not equal</option>
                            <option value="20" ${rule.operator === '20' ? 'selected' : ''}>is answered</option>
                            <option value="21" ${rule.operator === '21' ? 'selected' : ''}>not answered</option>
                        </select>
                        <button class="btn btn-sm btn-danger" style="padding: 4px 8px;" onclick="removeEditingRule(${idx})">‚úï</button>
                    </div>
                    <div id="edit-options-${idx}" style="display: flex; flex-wrap: wrap; gap: 6px;">
                        <span style="color: #666; font-size: 0.85rem;">Ch·ªçn Question ƒë·ªÉ hi·ªÉn th·ªã options...</span>
                    </div>
                </div>
            `;
            }

            function onEditQuestionChange(ruleIdx, questionId) {
                editingRules[ruleIdx].input_value = questionId;
                editingRules[ruleIdx].answers_values = [];
                loadOptionsForEditRule(ruleIdx, questionId, []);
            }

            function loadOptionsForEditRule(ruleIdx, questionId, selectedValues) {
                const container = document.getElementById(`edit-options-${ruleIdx}`);
                if (!container) return;

                const question = cachedQuestionsForCustom.find(q => q.id == questionId);
                if (!question || !question.options) {
                    container.innerHTML = '<span style="color: #666;">Kh√¥ng c√≥ options</span>';
                    return;
                }

                const selectedArray = Array.isArray(selectedValues) ? selectedValues : [selectedValues];

                container.innerHTML = `
                <div style="width: 100%; margin-bottom: 4px;">
                    <label style="display: inline-flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.8rem; color: #00d9ff;">
                        <input type="checkbox" onchange="toggleAllEditOptions(${ruleIdx}, this.checked)">
                        Ch·ªçn t·∫•t c·∫£
                    </label>
                </div>
                ${question.options.map(opt => {
                    const isChecked = selectedArray.includes(opt.id) || selectedArray.includes(String(opt.id));
                    return `
                        <label style="display: inline-flex; align-items: center; gap: 4px; padding: 5px 10px; background: ${isChecked ? 'rgba(0,255,136,0.2)' : 'rgba(0,217,255,0.1)'}; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                            <input type="checkbox" class="edit-opt-${ruleIdx}" value="${opt.id}" ${isChecked ? 'checked' : ''} onchange="updateEditOptionsFromCheckboxes(${ruleIdx})">
                            <span>${escapeHtml(opt.title)}</span>
                        </label>
                    `;
                }).join('')}
            `;
            }

            function toggleAllEditOptions(ruleIdx, checked) {
                document.querySelectorAll(`.edit-opt-${ruleIdx}`).forEach(cb => {
                    cb.checked = checked;
                });
                updateEditOptionsFromCheckboxes(ruleIdx);
            }

            function updateEditOptionsFromCheckboxes(ruleIdx) {
                const selectedOptions = [];
                document.querySelectorAll(`.edit-opt-${ruleIdx}:checked`).forEach(cb => {
                    selectedOptions.push(cb.value);
                });
                editingRules[ruleIdx].answers_values = selectedOptions;
            }

            function updateEditRuleData(ruleIdx, field, value) {
                editingRules[ruleIdx][field] = value;
            }

            function updateEditRuleOperator(ruleIdx, value) {
                editingRules[ruleIdx].next_operator = value;
            }

            function addEditingRule() {
                // Set next_operator on previous rule
                if (editingRules.length > 0) {
                    editingRules[editingRules.length - 1].next_operator = 'and';
                }

                editingRules.push({
                    input_value: '',
                    operator: '12',
                    answers_type: '17',
                    answers_values: [],
                    next_operator: ''
                });
                renderLogicEditor();
            }

            function removeEditingRule(idx) {
                editingRules.splice(idx, 1);
                // Fix next_operator on previous rule if exists
                if (idx > 0 && idx === editingRules.length) {
                    editingRules[idx - 1].next_operator = '';
                }
                renderLogicEditor();
            }

            function saveEditedLogic() {
                if (currentEditingQuotaIndex === null) return;

                // Get edited name and limit
                const newName = document.getElementById('editQuotaName')?.value?.trim();
                const newLimit = parseInt(document.getElementById('editQuotaLimit')?.value) || 50;

                if (!newName) {
                    return alert('Vui l√≤ng nh·∫≠p t√™n quota');
                }

                // Filter out empty rules
                const validRules = editingRules.filter(r =>
                    r.input_value && r.answers_values && r.answers_values.length > 0
                );

                if (validRules.length === 0) {
                    return alert('Vui l√≤ng th√™m √≠t nh·∫•t 1 ƒëi·ªÅu ki·ªán v·ªõi options ƒë∆∞·ª£c ch·ªçn');
                }

                // Build new logic structure
                const newLogic = {
                    templateName: `Custom Edit`,
                    isMultiRule: true,
                    rules: validRules.map((r, idx) => ({
                        input_value: r.input_value,
                        operator: r.operator,
                        answers_type: '17',
                        answers_values: r.answers_values,
                        next_operator: idx < validRules.length - 1 ? (r.next_operator || 'and') : ''
                    }))
                };

                // Update quota
                createQuotasList[currentEditingQuotaIndex].name = newName;
                createQuotasList[currentEditingQuotaIndex].limit = newLimit;
                createQuotasList[currentEditingQuotaIndex].logic = newLogic;

                renderCreatePreview();
                hideLogicDetailModal();
                alert('‚úÖ ƒê√£ l∆∞u thay ƒë·ªïi logic!');
            }

            function getOperatorName(op) {
                const ops = {
                    '4': '=',
                    '5': '‚â†',
                    '12': 'is one of',
                    '20': 'is answered',
                    '21': 'is not answered',
                    '14': 'contains'
                };
                return ops[op] || op;
            }

            function hideLogicDetailModal() {
                document.getElementById('logicDetailModal').classList.add('hidden');
                currentEditingQuotaIndex = null;
                editingRules = [];
            }

            function saveLogicFromJson() {
                if (currentEditingQuotaIndex === null) return;

                try {
                    const jsonText = document.getElementById('logicJsonEditor').value;
                    const newLogic = JSON.parse(jsonText);
                    createQuotasList[currentEditingQuotaIndex].logic = newLogic;
                    renderCreatePreview();
                    alert('‚úÖ ƒê√£ l∆∞u thay ƒë·ªïi logic!');
                    hideLogicDetailModal();
                } catch (e) {
                    alert('‚ùå JSON kh√¥ng h·ª£p l·ªá: ' + e.message);
                }
            }

            function clearQuotaLogic() {
                if (currentEditingQuotaIndex === null) return;
                if (!confirm('X√≥a to√†n b·ªô logic c·ªßa quota n√†y?')) return;

                createQuotasList[currentEditingQuotaIndex].logic = null;
                renderCreatePreview();
                hideLogicDetailModal();
                alert('‚úÖ ƒê√£ x√≥a logic');
            }

            // Updated clone function using modal
            function cloneCurrentQuota() {
                const groups = buildCustomLogicGroups();
                if (groups.length === 0) {
                    return alert('Kh√¥ng c√≥ logic n√†o ƒë·ªÉ clone');
                }

                showMultilineModal(
                    '‚ôªÔ∏è Clone Quota - Nh·∫≠p danh s√°ch t√™n quota (m·ªói d√≤ng 1 t√™n)',
                    '20-29 + Nam\n30-39 + Nam\n40-49 + Nam\n50-59 + Nam',
                    (text) => {
                        if (!text.trim()) return;

                        const names = text.split('\n').filter(n => n.trim());
                        const limit = parseInt(document.getElementById('customQuotaLimit').value) || 50;

                        names.forEach(name => {
                            const newQuota = {
                                name: name.trim(),
                                limit: limit,
                                group: 'custom-logic',
                                status: 'pending',
                                logic: {
                                    templateName: `Custom: ${name.trim()}`,
                                    isCustomGroups: true,
                                    groups: JSON.parse(JSON.stringify(groups))
                                },
                                originalIndex: createQuotasList.length
                            };
                            createQuotasList.push(newQuota);
                        });

                        renderCreatePreview();
                        document.getElementById('createPreviewCard').classList.remove('hidden');
                        alert(`‚úÖ ƒê√£ th√™m ${names.length} quota v·ªõi c√πng c·∫•u tr√∫c logic!`);
                    }
                );
            }

            // Updated addMultiple function using modal
            function addMultipleCustomQuotas() {
                const groups = buildCustomLogicGroups();
                if (groups.length === 0) {
                    return alert('Vui l√≤ng thi·∫øt l·∫≠p logic tr∆∞·ªõc');
                }

                showMultilineModal(
                    '‚ûï Th√™m nhi·ªÅu quota - Nh·∫≠p danh s√°ch t√™n (m·ªói d√≤ng 1 t√™n)',
                    'HN + Nam + 20-29\nHN + Nam + 30-39\nHCM + N·ªØ + 20-29\nHCM + N·ªØ + 30-39',
                    (text) => {
                        if (!text.trim()) return;

                        const names = text.split('\n').filter(n => n.trim());
                        const limit = parseInt(document.getElementById('customQuotaLimit').value) || 50;

                        names.forEach(name => {
                            const newQuota = {
                                name: name.trim(),
                                limit: limit,
                                group: 'custom-logic',
                                status: 'pending',
                                logic: {
                                    templateName: `Custom: ${name.trim()}`,
                                    isCustomGroups: true,
                                    groups: JSON.parse(JSON.stringify(groups))
                                },
                                originalIndex: createQuotasList.length
                            };
                            createQuotasList.push(newQuota);
                        });

                        renderCreatePreview();
                        document.getElementById('createPreviewCard').classList.remove('hidden');
                        alert(`‚úÖ ƒê√£ th√™m ${names.length} quota!`);
                    }
                );
            }
        </script>

        <!-- Multiline Input Modal -->
        <div id="multilineModal" class="hidden"
            style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; align-items: center; justify-content: center;">
            <div
                style="background: #1a1a2e; border-radius: 12px; padding: 24px; width: 90%; max-width: 600px; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                <h3 id="multilineModalTitle" style="color: #00d9ff; margin-bottom: 16px;">Nh·∫≠p danh s√°ch</h3>
                <textarea id="multilineModalTextarea" rows="10"
                    style="width: 100%; margin-bottom: 16px; font-family: monospace;"></textarea>
                <p style="color: #8892b0; font-size: 0.85rem; margin-bottom: 16px;">üí° M·ªói d√≤ng l√† 1 t√™n quota. Nh·∫•n
                    Enter
                    ƒë·ªÉ xu·ªëng d√≤ng.</p>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="hideMultilineModal()">‚ùå H·ªßy</button>
                    <button class="btn btn-primary" onclick="submitMultilineModal()">‚úÖ X√°c nh·∫≠n</button>
                </div>
            </div>
        </div>

        <!-- Logic Detail Modal -->
        <div id="logicDetailModal" class="hidden"
            style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 9999; display: flex; align-items: center; justify-content: center;">
            <div
                style="background: #1a1a2e; border-radius: 12px; padding: 24px; width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h3 id="logicDetailTitle" style="color: #00d9ff;">üìã Chi ti·∫øt Logic</h3>
                    <button class="btn btn-sm btn-secondary" onclick="hideLogicDetailModal()">‚úï</button>
                </div>
                <div id="logicDetailContent" style="color: #fff;">
                    <!-- Logic detail will be rendered here -->
                </div>
                <div
                    style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                    <button class="btn btn-danger btn-sm" onclick="clearQuotaLogic()">üóëÔ∏è X√≥a logic</button>
                    <button class="btn btn-secondary" onclick="hideLogicDetailModal()">‚ùå H·ªßy</button>
                    <button class="btn btn-primary" onclick="saveEditedLogic()">üíæ L∆∞u thay ƒë·ªïi</button>
                </div>
            </div>
        </div>

        <style>
            #multilineModal.hidden,
            #logicDetailModal.hidden {
                display: none !important;
            }
        </style>
</body>

</html>